sim_data <- function(n = 100,
                     n_days = 28,
                     
                     # effect parameters
                     b = 0.8, # effect in unstandardized units (scaled for 5-25 range)
                     mu = 15, # grand mean of the outcome (center of 5-25 range)
                     
                     
                     # random effects parameters
                     tau_int = 2.5,   # Random intercept SD (between-person variance)
                     tau_slope = .05,  # Random slope SD 
                     within_person_sd = 2.0, # Within-person SD (scaled for 5-25 range)
                     
                     # AR(1) parameters
                     phi = 0.8,     # Autocorrelation coefficient
                     effect_shape = "grow",
                     k = .5, # affects how quickly the plateau effect plateaus
                     
                     mediated = FALSE,
                     
                     # playtime parameters
                     playtime_grand_mean = 1,   # Average baseline playtime in hours
                     playtime_grand_sd = .5,   # SD for baseline playtime in log units (log-normal distribution)
                     daily_play_sd = 0.5      # Daily noise in playtime
                     # compliance_mean = 0.7,    # Average reduction (in hours) for intervention group during intervention period
)     
{
  dat <- tibble(
    id = 1:n,
    age = sample(18:36, n, replace = TRUE),
    gender = sample(c("man","woman","non-binary"), n, prob = c(.45, .45, .1), replace = TRUE),
    condition = factor(sample(c("control", "intervention"), n, replace = TRUE)),
    experimental_condition = ifelse(condition == "intervention", 1, 0),
    intercept_sq = rnorm(n, 0, tau_int), # Renamed from intercept_wb
    slope_sq = rnorm(n, 0, tau_slope), # Renamed from slope_wb
    intercept_play = rlnorm(n, log(playtime_grand_mean), playtime_grand_sd),
  ) |> 
    # expand to 28 waves per id
    crossing(
      day = 1:n_days
    ) |> 
    mutate(
      intervention_period = as.numeric(day > 7 & day < 22),
      intervention_active = intervention_period & condition == "intervention",
      compliance = ifelse(intervention_active, rkumar(n*n_days, a = .05, b = .1), 0),
      
      # In the baseline period, play is just the subject's baseline plus some day-to-day noise
      # During the intervention, experimental subjects reduce play by their compliance amount
      playtime = (1 - compliance) * rlnorm(n, log(intercept_play), daily_play_sd),
      effect_time = case_when(
        effect_shape == "plateau" ~ if_else(intervention_period == 1, (b + slope_sq) * (1-exp(-k * (day - 7))), 0), # Renamed from slope_wb
        effect_shape == "grow" ~ if_else(intervention_period == 1, (day - 7) * ((b + slope_sq)/7), 0), # Renamed from slope_wb
        TRUE ~ NA_real_
      ),
    ) |> 
    group_by(id) |> 
    mutate(
      
      baseline_playtime = mean(playtime[day <= 7]),
      reduction = baseline_playtime - playtime, # The mediator: reduction in play relative to the baseline average
      sigma = within_person_sd * sqrt(1-phi^2),
      # Generate AR(1) errors for each participant
      e = as.numeric(arima.sim(n = n_days, 
                               model = list(ar = phi), 
                               sd = sigma)),
      # Add random effect + fixed effect + AR(1) error
      sleep_quality_raw = case_when( # Renamed from wellbeing
        mediated == TRUE ~ mu + 
                            intercept_sq + # Renamed from intercept_wb
                            effect_time * reduction + 
                            .01*(age-18) +
                            -.05*(gender %in% c("women","non-binary")) + 
                            e,
        mediated == FALSE ~ mu + 
                            intercept_sq + # Renamed from intercept_wb
                            effect_time * experimental_condition * intervention_period + 
                            .01*(age-18) +
                            -.05*(gender %in% c("women","non-binary")) + 
                            e
      ),
      # Constrain to 5-25 range and round to integers
      sleep_quality = round(pmax(5, pmin(25, sleep_quality_raw)))
    ) |> 
    ungroup() |> 
    mutate(across(where(is.numeric), ~ round(., 3)))
  
  dat

}

#| label: sim-data-example
#| code-summary: "Show code (sim data example)"

sim_data(n = 10, n_days = 10, effect_shape = "grow")


#' Simulate Dropout
#'
#' Introduces missingness and dropout into a dataset by randomly assigning records as missing
#' or dropped out. Once a participant is dropped out, all subsequent records become missing.
#'
#' @param dat A tibble generated by \code{sim_data()}.
#'
#' @return A tibble of the same structure as \code{dat}, but with some \code{sleep_quality} values set to NA. # Renamed from wellbeing
#'
sim_dropout <- function(dat) {
  
  dropout <- dat |> 
    mutate(
      missing = sample(c(TRUE, FALSE), n(), replace = TRUE, prob = c(.10, .90)),
      dropout = sample(c(TRUE, FALSE), n(), replace = TRUE, prob = c(.01, .99))
    ) |>
    mutate(
      missing = ifelse(cumsum(dropout) > 0, TRUE, missing),
      .by = id
    ) |>
    arrange(as.integer(id), day) |> 
    mutate(sleep_quality = ifelse(missing, NA, sleep_quality)) # Renamed from wellbeing
  dropout
}

#| label: fit-functions
#| code-summary: "Show code (fit functions)"

#' Fit a Generalized Additive Model (GAM)
#'
#' Fits a GAM model to the provided dataset using \code{mgcv::gam}, including an AR(1)
#' correlation structure and random intercept for each ID.
#'
#' @param dat A tibble of repeated-measures data (e.g., from \code{sim_data()} and \code{sim_dropout()}).
#'
#' @return An object of class \code{gam}, which is the fitted GAM model.
#'
fit_gam <- function(dat) {
  
  gam(sleep_quality ~ # Renamed from wellbeing
        condition:intervention_period + age + gender +
        s(id, bs = "re") + 
        s(day, by = condition, bs = "tp"), 
      data = dat,
      correlation = corAR1(form = ~ day | id))
}

fit_gam_no_main <- function(dat) {
  
  gam(sleep_quality ~ # Renamed from wellbeing
        age + gender +
        s(id, bs = "re") + 
        s(day, by = condition, bs = "tp"), 
      data = dat,
      correlation = corCAR1(form = ~ day | id))
}

#' Fit a Multi-Level Model (MLM)
#'
#' Fits a linear mixed-effects model (LME) with random intercept for each ID using \code{lme4::lmer}.
#'
#' @param dat A tibble of repeated-measures data (e.g., from \code{sim_data()} and \code{sim_dropout()}).
#'
#' @return An object of class \code{lmerMod}, which is the fitted MLM model.
#'
fit_mlm <- function(dat) {
  # lmer(sleep_quality ~ condition*intervention_period + age + gender + (1|id), data = dat) # Renamed from wellbeing
  lme(
    fixed = sleep_quality ~ condition*intervention_period + age + gender, # Renamed from wellbeing
    random = ~ 1|id,  # or use a more flexible structure if needed
    correlation = corCAR1(form = ~ day | id),
    method = "ML",
    data = dat |> filter(!is.na(sleep_quality)) # Renamed from wellbeing
  )
}

fit_mlm_simple <- function(dat) {
  
  tmp <- dat |> 
    group_by(id) |> 
    # take the mean of days 1-7 
    mutate(baseline = mean(sleep_quality[day < 8], na.rm = TRUE)) |> # Renamed from wellbeing
    filter(intervention_period == 1) |> 
    filter(!is.na(sleep_quality)) # Renamed from wellbeing
  
  lme(
    fixed = sleep_quality ~ baseline + condition + age + gender, # Renamed from wellbeing
    random = ~ 1|id,  # Only random intercept since condition is between-subjects
    correlation = corCAR1(form = ~ day | id),
    method = "ML",
    data = tmp |> filter(!is.na(sleep_quality)) # Renamed from wellbeing
  )
}

fit_gls <- function(dat) {
  
  gls(
    sleep_quality ~ condition * intervention_period + age + gender, # Renamed from wellbeing
    correlation = corCAR1(form = ~ day | id),
    data = dat |> filter(!is.na(sleep_quality)) # Renamed from wellbeing
  )
}

fit_gls_simple <- function(dat) {
  
  tmp <- dat |> 
    group_by(id) |> 
    # take the mean of days 1-7 
    mutate(baseline = mean(sleep_quality[day < 8], na.rm = TRUE)) |> # Renamed from wellbeing
    filter(intervention_period == 1) |> 
    filter(!is.na(sleep_quality)) # Renamed from wellbeing
  
  gls(
    sleep_quality ~ condition + baseline + age + gender, # Renamed from wellbeing
    correlation = corAR1(form = ~ day | id),
    data = tmp
  )
}

fit_gls_spline <- function(dat) {
  gls(
    sleep_quality ~ ns(day, df = 4) * intervention_period * condition, # Renamed from wellbeing, corrected comma
    correlation = corCAR1(form = ~ day | id),
    data = dat
  )
}

fit_mlm_reduction <- function(dat) {
  lme(
    fixed = sleep_quality ~ intervention_active*reduction + age + gender, # Renamed from wellbeing
    random = ~ 1 + intervention_active*reduction | id,
    correlation = corCAR1(form = ~ day | id),
    data = dat
  )
}

# Helper function to extract the focal effect for GLS models
extract_marginal_effect <- function(mod, dat, focal_term = "conditionintervention") {
  # Here we assume your GLS model is specified with condition*intervention_period
  # and you want the effect of condition (e.g., intervention vs. control) during intervention.
  # We create a reference grid that fixes intervention_period at 1.
  rg <- ref_grid(mod, data = dat, at = list(intervention_period = 1))
  
  # Obtain estimated marginal means for each condition.
  emm <- emmeans(rg, ~ condition)
  
  # Compute the pairwise contrast (e.g., intervention - control)
  # Adjust names as needed. The contrast below returns a one-row summary.
  contr <- emmeans::contrast(emm, method = list("intervention - control" = c(-1, 1)), adjust = "none")
  contr_sum <- summary(contr, infer = TRUE)
  
  # Construct a one-row data frame with consistent column names.
  # If you have more than one contrast, you might need to filter for the one of interest.
  df <- data.frame(
    term = focal_term,
    estimate = contr_sum$estimate,
    std.error = contr_sum$SE,
    conf.low = contr_sum$lower.CL,
    conf.high = contr_sum$upper.CL,
    row.names = NULL
  )
  
  return(df)
}

#' Simulation Study Orchestrator
#'
#' A higher-level function that ties together data simulation, dropout, and model fitting,
#' returning a tidy summary of the fitted model parameters.
#'
#' @param model_function A function to fit the model. Defaults to \code{fit_gam}.
#' @param n Number of participants passed to \code{sim_data()}. Default is 1000.
#' @param n_days Number of time points per participant passed to \code{sim_data()}. Default is 28.
#' @param b Fixed effect for the intervention slope passed to \code{sim_data()}. Default is 0.01.
#' @param phi AR(1) autocorrelation coefficient passed to \code{sim_data()}. Default is 0.7.
#' @param sigma AR(1) residual standard deviation passed to \code{sim_data()}. Default is 0.6.
#'
#' @return A data frame (tibble) of model estimates from \code{broom::tidy(parametric = TRUE)}.
#'

# Updated simulation orchestrator that handles GLS models separately.
sim_study <- function(model = "fit_gam", focal_term = "intervention_activeTRUE:reduction", ...) {
  args <- list(...)
  dat <- do.call(sim_data, args)
  model_function <- get(model)
  
  mod <- model_function(dat)
  
  if (model %in% c("fit_gam_no_main","fit_gls_spline")) {
    # Extract the effect using our helper function.
    result <- suppressMessages(extract_marginal_effect(mod, 
                                                       dat, 
                                                       focal_term = focal_term))
  } else {
    # For models that work with broom, extract the focal parameter.
    # Adjust the filtering term as needed.
    result <- broom::tidy(mod, parametric = TRUE) %>%
      filter(term == focal_term) |> 
      # filter(
      #   term == "conditionintervention:intervention_period" | 
      #     (model %in% c("fit_mlm_simple","fit_gls_simple") & term == "conditionintervention")
      # ) |> 
      mutate(
        conf.low = estimate - 1.96 * std.error,
        conf.high = estimate + 1.96 * std.error
      )
  }
  result
}