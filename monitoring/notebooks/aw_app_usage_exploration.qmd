---
title: "ActivityWatch App Usage Data Exploration by Study Day"
author: "Gaming Reduction Study Analysis"
format: 
  html:
    page-layout: full
    code-fold: true
    code-summary: "Show code"
    toc: true
    toc-depth: 3
    toc-location: left
    grid:
      sidebar-width: 250px
      body-width: 1400px
      margin-width: 100px
    css: |
      .quarto-container {
        max-width: none !important;
      }
      .content {
        max-width: 1400px !important;
        margin: 0 auto;
      }
      table {
        font-size: 0.85em;
      }
      .cell-output-display {
        overflow-x: auto;
      }
editor: visual
---

## Overview

This notebook explores ActivityWatch app usage data from the gaming reduction study, focusing on data availability across study days (1-28) for each participant. The analysis uses enrollment dates to calculate study days and assess whether donated data exists for each day, with particular emphasis on gaming app usage patterns after AI-powered app classification.

```{r setup, include=FALSE}
library(tidyverse)
library(lubridate)
library(knitr)
library(DT)

# Set options
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Data Refresh Pipeline

```{r data-refresh}
# Set to FALSE to skip data refresh and use existing files
REFRESH_DATA <- TRUE

# Cache duration: refresh data if older than 1 hour
CACHE_DURATION_HOURS <- 1

# Define the output files to check for caching
AW_DATA_FILE <- "../../.tmp/aw_app_usage.csv"
AW_ENRICHED_FILE <- "../../.tmp/aw_app_usage_enriched.csv"
PARTICIPANT_REPORT_FILE <- "../../.tmp/participant_report.csv"

# Check if we need to refresh data based on file age
should_refresh_data <- function(file_path, cache_hours = 1) {
  if (!file.exists(file_path)) {
    return(TRUE)
  }
  
  file_age_hours <- as.numeric(difftime(Sys.time(), file.mtime(file_path), units = "hours"))
  return(file_age_hours > cache_hours)
}

# Step 1: Refresh raw ActivityWatch data (this also generates participant_report.csv)
if (REFRESH_DATA && (should_refresh_data(AW_DATA_FILE, CACHE_DURATION_HOURS) || should_refresh_data(PARTICIPANT_REPORT_FILE, CACHE_DURATION_HOURS))) {
  cat("=== REFRESHING ACTIVITYWATCH DATA FROM SUPABASE ===\n")
  cat("Step 1/2: Pulling ActivityWatch data from Supabase...\n")
  
  step1_result <- tryCatch({
    cat("‚è±Ô∏è This may take several minutes to pull data from Supabase and Qualtrics...\n")
    system2(
      "python3",
      args = c("../../monitoring/join_diary_activitywatch.py", "--output-dir", "../../.tmp", "--verbose"),
      stdout = TRUE,
      stderr = TRUE,
      wait = TRUE,
      timeout = 1800  # 30 minutes timeout
    )
  }, error = function(e) {
    cat("‚ùå Error in Step 1:", e$message, "\n")
    return(NULL)
  })
  
  if (!is.null(attr(step1_result, "status")) && attr(step1_result, "status") != 0) {
    cat("‚ö†Ô∏è Warning: Step 1 exited with non-zero status:", attr(step1_result, "status"), "\n")
    if (length(step1_result) > 0) {
      cat("Last 20 lines of output:\n")
      cat(paste(tail(step1_result, 20), collapse = "\n"), "\n\n")
    }
  } else if (!is.null(step1_result)) {
    cat("‚úÖ Step 1 completed successfully\n")
    if (length(step1_result) > 5) {
      cat("Last few lines of output:\n")
      cat(paste(tail(step1_result, 5), collapse = "\n"), "\n\n")
    }
  } else {
    cat("‚ùå Step 1 failed or timed out\n")
  }
} else if (REFRESH_DATA) {
  if (file.exists(AW_DATA_FILE) && file.exists(PARTICIPANT_REPORT_FILE)) {
    aw_age_hours <- as.numeric(difftime(Sys.time(), file.mtime(AW_DATA_FILE), units = "hours"))
    report_age_hours <- as.numeric(difftime(Sys.time(), file.mtime(PARTICIPANT_REPORT_FILE), units = "hours"))
    cat("=== USING CACHED ACTIVITYWATCH DATA ===\n")
    cat(sprintf("AW data file is %.1f hours old, participant report is %.1f hours old (cache valid for %d hours)\n", 
                aw_age_hours, report_age_hours, CACHE_DURATION_HOURS))
    cat("Skipping refresh to save time.\n")
  }
} else {
  cat("=== USING EXISTING ACTIVITYWATCH DATA ===\n")
  cat("Skipping data refresh (REFRESH_DATA = FALSE)\n")
}

# Step 2: Enrich with gaming classification
if (REFRESH_DATA && should_refresh_data(AW_ENRICHED_FILE, CACHE_DURATION_HOURS)) {
  cat("\nStep 2/2: Enriching ActivityWatch data with game classification...\n")
  
  step2_result <- tryCatch({
    cat("‚è±Ô∏è This may take several minutes to classify gaming apps...\n")
    system2(
      "python3",
      args = c("../../monitoring/ocr/app_game_classifier.py", AW_DATA_FILE, "--format", "activitywatch", "--output", AW_ENRICHED_FILE),
      stdout = TRUE,
      stderr = TRUE,
      wait = TRUE,
      timeout = 900  # 15 minutes timeout
    )
  }, error = function(e) {
    cat("‚ùå Error in Step 2:", e$message, "\n")
    return(NULL)
  })
  
  if (!is.null(attr(step2_result, "status")) && attr(step2_result, "status") != 0) {
    cat("‚ö†Ô∏è Warning: Step 2 exited with non-zero status:", attr(step2_result, "status"), "\n")
    if (length(step2_result) > 0) {
      cat("Last 15 lines of output:\n")
      cat(paste(tail(step2_result, 15), collapse = "\n"), "\n\n")
    }
  } else if (!is.null(step2_result)) {
    cat("‚úÖ Step 2 completed successfully\n")
    if (length(step2_result) > 3) {
      cat("Last few lines of output:\n")
      cat(paste(tail(step2_result, 3), collapse = "\n"), "\n\n")
    }
  } else {
    cat("‚ùå Step 2 failed or timed out\n")
  }
  
  cat("\nüéâ ActivityWatch data pipeline completed!\n\n")
} else if (REFRESH_DATA && file.exists(AW_ENRICHED_FILE)) {
  file_age_hours <- as.numeric(difftime(Sys.time(), file.mtime(AW_ENRICHED_FILE), units = "hours"))
  cat(sprintf("\nEnriched data file is %.1f hours old (cache valid for %d hours)\n", file_age_hours, CACHE_DURATION_HOURS))
  cat("Skipping enrichment to save time.\n\n")
} else if (!file.exists(AW_ENRICHED_FILE) && file.exists(AW_DATA_FILE)) {
  cat("\nEnriched file missing - running classification...\n")
  system2("python3", args = c("../../monitoring/ocr/app_game_classifier.py", AW_DATA_FILE, "--format", "activitywatch", "--output", AW_ENRICHED_FILE))
  cat("‚úÖ Game classification completed\n\n")
}

# Check if files exist and show their info
files_to_check <- c(AW_DATA_FILE, AW_ENRICHED_FILE, PARTICIPANT_REPORT_FILE)
for (file in files_to_check) {
  if (file.exists(file)) {
    file_info <- file.info(file)
    cat(sprintf("‚úì %s exists (modified: %s, size: %s bytes)\n", 
                basename(file), 
                file_info$mtime, 
                format(file_info$size, big.mark = ",")))
  } else {
    cat(sprintf("‚úó %s not found\n", basename(file)))
  }
}
cat("\n")
```

## Data Loading

```{r load-data}
# Load the enriched ActivityWatch app usage data (with game classification)
if (file.exists(AW_ENRICHED_FILE)) {
  aw_data <- read_csv(AW_ENRICHED_FILE)
  cat("Using enriched ActivityWatch data with game classifications\n")
} else {
  aw_data <- read_csv(AW_DATA_FILE)
  # Add default game classification columns if missing
  if (!"ProbGame" %in% names(aw_data)) {
    aw_data$ProbGame <- "No"
  }
  if (!"LLM_conf" %in% names(aw_data)) {
    aw_data$LLM_conf <- 1
  }
  cat("Using raw ActivityWatch data (no game classifications available)\n")
}

# Load participant enrollment data
participant_report <- read_csv(PARTICIPANT_REPORT_FILE)

# Check if any participants are missing Condition data
participants_missing_condition <- participant_report %>%
  filter(is.na(Condition) | Condition == "")

if (nrow(participants_missing_condition) > 0) {
  cat("‚ö†Ô∏è WARNING: Found", nrow(participants_missing_condition), "participants without Condition data:\n")
  print(participants_missing_condition$RANDOM_ID)
  cat("\nConsider re-running with REFRESH_DATA <- TRUE to pull fresh contact list data.\n\n")
}

# Display data structure
cat("ActivityWatch Data Structure:\n")
glimpse(aw_data)

cat("\nParticipant Report Structure:\n")
glimpse(participant_report)

cat("\nNumber of AW sessions:", nrow(aw_data), "\n")
cat("Number of participants with enrollment dates:", n_distinct(participant_report$RANDOM_ID), "\n")

# Show condition distribution
if ("Condition" %in% names(participant_report)) {
  condition_counts <- participant_report %>%
    count(Condition) %>%
    mutate(Condition = ifelse(is.na(Condition) | Condition == "", "Missing", Condition))
  
  cat("\nCondition distribution in participant report:\n")
  print(condition_counts)
}
```

## Data Preparation

```{r data-prep}
# Process ActivityWatch data and join with enrollment information
aw_processed <- aw_data %>%
  mutate(
    submission_id = as.character(submission_id),
    session_datetime = ymd_hms(session_datetime),
    session_date = as.Date(session_datetime),
    Duration = as.numeric(`Duration (min)`),
    platform = tolower(trimws(platform)),  # Standardize platform
    ProbGame = case_when(
      ProbGame == "Yes" ~ TRUE,
      ProbGame == "No" ~ FALSE,
      TRUE ~ NA
    )
  )

# Join with participant enrollment data using submission_id mapping
# First, create a mapping from submission_id to RANDOM_ID
submission_mapping <- participant_report %>%
  select(RANDOM_ID, submission_ids_list) %>%
  mutate(RANDOM_ID = as.character(RANDOM_ID)) %>%
  filter(!is.na(submission_ids_list) & submission_ids_list != "") %>%
  mutate(
    # Clean the Python list format: remove brackets and quotes
    cleaned_ids = str_replace_all(submission_ids_list, "[\\[\\]']", "")
  ) %>%
  separate_rows(cleaned_ids, sep = ", ") %>%
  mutate(submission_id = trimws(cleaned_ids)) %>%
  select(submission_id, RANDOM_ID) %>%
  distinct()

# Join ActivityWatch data with enrollment information
aw_processed <- aw_processed %>%
  left_join(submission_mapping, by = "submission_id") %>%
  left_join(
    participant_report %>% 
      select(RANDOM_ID, EnrollmentDate, Condition) %>%
      mutate(
        RANDOM_ID = as.character(RANDOM_ID),
        EnrollmentDate = ymd(EnrollmentDate)
      ),
    by = "RANDOM_ID"
  ) %>%
  filter(!is.na(EnrollmentDate)) %>%
  mutate(
    # Calculate study day based on enrollment date
    study_day = as.numeric(session_date - EnrollmentDate) + 1
  ) %>%
  filter(study_day >= 1 & study_day <= 28)  # Focus on 28-day study period

# Platform summary
platform_summary <- aw_processed %>%
  group_by(platform) %>%
  summarise(
    participants = n_distinct(RANDOM_ID),
    sessions = n(),
    total_duration = sum(Duration, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(participants))

cat("\nPlatform Summary:\n")
print(platform_summary)

cat("\nData after processing:\n")
cat("Participants with enrollment dates:", n_distinct(aw_processed$RANDOM_ID), "\n")
cat("Date range:", range(aw_processed$session_date, na.rm = TRUE), "\n")
cat("Study day range:", range(aw_processed$study_day, na.rm = TRUE), "\n")
cat("Available platforms:", paste(unique(aw_processed$platform), collapse = ", "), "\n")

# Check join success
participants_in_aw <- n_distinct(aw_processed$submission_id)
participants_with_random_id <- n_distinct(aw_processed$RANDOM_ID[!is.na(aw_processed$RANDOM_ID)])
cat("Submission IDs in AW data:", participants_in_aw, "\n")
cat("Successfully mapped to RANDOM_IDs:", participants_with_random_id, "\n")
```

## Participant Overview

```{r participant-overview}
# Summary by participant with platform information
participant_summary <- aw_processed %>%
  group_by(RANDOM_ID, Condition, EnrollmentDate) %>%
  summarise(
    platforms = paste(sort(unique(platform)), collapse = ", "),
    total_apps = n_distinct(App),
    total_sessions = n(),
    total_duration = sum(Duration, na.rm = TRUE),
    gaming_apps = n_distinct(App[ProbGame == TRUE]),
    gaming_sessions = sum(ProbGame == TRUE, na.rm = TRUE),
    gaming_duration = sum(Duration[ProbGame == TRUE], na.rm = TRUE),
    study_days_with_data = n_distinct(study_day),
    first_day = min(study_day),
    last_day = max(study_day),
    .groups = "drop"
  ) %>%
  mutate(
    # Calculate study completion status
    report_generation_date = Sys.Date(),
    study_end_date = EnrollmentDate + days(27), # 28 days total (0-27)
    days_since_enrollment = as.numeric(report_generation_date - EnrollmentDate),
    study_should_be_complete = days_since_enrollment >= 28,
    study_completion_status = case_when(
      !study_should_be_complete ~ "üü° In Progress",
      study_should_be_complete & study_days_with_data >= 20 ~ "‚úÖ Complete",
      days_since_enrollment > 30 & study_days_with_data < 20 ~ "üî¥ Incomplete",
      TRUE ~ "‚ùì Unknown"
    ),
    status_category = case_when(
      !study_should_be_complete ~ "in_progress",
      study_should_be_complete & study_days_with_data >= 20 ~ "complete",
      days_since_enrollment > 30 & study_days_with_data < 20 ~ "incomplete",
      TRUE ~ "unknown"
    ),
    gaming_percentage = round((gaming_duration / total_duration) * 100, 1)
  ) %>%
  arrange(status_category, RANDOM_ID)

# Display interactive participant table
datatable(participant_summary %>% select(-status_category), 
      caption = "ActivityWatch Participant Summary with Study Completion Status and Platforms",
      colnames = c("Participant ID", "Condition", "Enrollment Date", "Platforms", "Total Apps", "Total Sessions", 
                   "Total Duration (min)", "Gaming Apps", "Gaming Sessions", "Gaming Duration (min)",
                   "Days with Data", "First Day", "Last Day", "Report Date", "Study End Date", 
                   "Days Since Enrollment", "Should Complete", "Status", "Gaming %"),
      options = list(
        pageLength = 20,
        scrollX = TRUE,
        columnDefs = list(list(width = '120px', targets = c(0, 1, 16))),
        order = list(list(16, 'asc'))
      ),
      filter = 'top') %>%
      formatRound(columns = c(5, 8, 17), digits = 1)

# Summary of completion status
status_summary <- participant_summary %>%
  count(study_completion_status, status_category) %>%
  arrange(status_category)

cat("\n=== ACTIVITYWATCH STUDY COMPLETION STATUS SUMMARY ===\n")
for(i in 1:nrow(status_summary)) {
  cat(status_summary$study_completion_status[i], ":", status_summary$n[i], "participants\n")
}
```

## Data Availability Matrix

```{r data-availability-matrix}
# Create comprehensive data availability matrix for ActivityWatch participants by platform
study_day_availability <- aw_processed %>%
  group_by(RANDOM_ID, platform, study_day) %>%
  summarise(
    has_data = TRUE,
    num_apps = n_distinct(App),
    total_duration = sum(Duration, na.rm = TRUE),
    gaming_duration = sum(ifelse(ProbGame == TRUE & !is.na(ProbGame), Duration, 0), na.rm = TRUE),
    .groups = "drop"
  )

# Debug: Check gaming duration calculation by platform
cat("Gaming duration check by platform:\n")
gaming_by_platform <- study_day_availability %>%
  group_by(platform) %>%
  summarise(
    total_gaming_duration = sum(gaming_duration, na.rm = TRUE),
    participants = n_distinct(RANDOM_ID),
    .groups = "drop"
  )
print(gaming_by_platform)

# Let's also check the raw data by platform
gaming_check_platform <- aw_processed %>%
  filter(ProbGame == TRUE) %>%
  group_by(platform) %>%
  summarise(
    total_gaming_sessions = n(),
    total_gaming_duration = sum(Duration, na.rm = TRUE),
    .groups = "drop"
  )
cat("Raw gaming data check by platform:\n")
print(gaming_check_platform)

# Create separate complete grids for each platform
platform_types <- unique(aw_processed$platform)
all_study_days <- 1:28

# Create platform-specific grids
platform_grids <- list()

for(platform in platform_types) {
  platform_participants <- unique(aw_processed$RANDOM_ID[aw_processed$platform == platform])
  
  platform_grid <- expand_grid(
    RANDOM_ID = platform_participants,
    study_day = all_study_days,
    platform = platform
  ) %>%
    left_join(study_day_availability, by = c("RANDOM_ID", "platform", "study_day")) %>%
    mutate(
      has_data = ifelse(is.na(has_data), FALSE, has_data),
      gaming_duration = ifelse(is.na(gaming_duration), 0, gaming_duration)
    ) %>%
    left_join(
      participant_summary %>% select(RANDOM_ID, Condition, EnrollmentDate, 
                                   study_completion_status, status_category),
      by = "RANDOM_ID"
    )
  
  platform_grids[[platform]] <- platform_grid
  
  cat(sprintf("Platform '%s': %d participants, %d total records\n", 
              platform, length(platform_participants), nrow(platform_grid)))
}

# Combine all platform grids
complete_grid <- bind_rows(platform_grids)

# Debug: Check the join results
cat("\nCombined grid dimensions:", nrow(complete_grid), "rows\n")
cat("Participants with Condition data:", sum(!is.na(complete_grid$Condition)), "\n")
cat("Unique participants in complete_grid:", n_distinct(complete_grid$RANDOM_ID), "\n")

# Summary statistics by platform
availability_summary_by_platform <- complete_grid %>%
  group_by(platform, study_day) %>%
  summarise(
    participants_with_data = sum(has_data),
    total_participants = n(),
    percentage_with_data = (participants_with_data / total_participants) * 100,
    .groups = "drop"
  )

# Overall summary (combined)
availability_summary <- complete_grid %>%
  group_by(study_day) %>%
  summarise(
    participants_with_data = sum(has_data),
    total_participants = n(),
    percentage_with_data = (participants_with_data / total_participants) * 100,
    .groups = "drop"
  )

# Display platform-specific summaries
for(platform in platform_types) {
  platform_summary_data <- availability_summary_by_platform %>% filter(platform == platform)
  
  cat(sprintf("\n=== %s DATA AVAILABILITY SUMMARY ===\n", toupper(platform)))
  platform_table <- datatable(platform_summary_data %>% select(-platform),
            caption = paste("Data Availability Summary by Study Day -", stringr::str_to_title(platform)),
            colnames = c("Study Day", "Participants with Data", "Total Participants", "Percentage with Data"),
            options = list(
              pageLength = 10,
              scrollX = TRUE,
              order = list(list(0, 'asc'))
            ),
            filter = 'top') %>%
    formatRound(columns = c(4), digits = 1)
  
  print(platform_table)
}
```

## Visualization: Data Availability Heatmaps by Platform

```{r heatmap-visualization}
# Create separate heatmaps for each platform
for(platform in platform_types) {
  platform_data <- complete_grid %>% filter(platform == platform)
  platform_participants <- unique(platform_data$RANDOM_ID)
  
  cat(sprintf("\n=== %s PLATFORM HEATMAP ===\n", toupper(platform)))
  cat(sprintf("Participants: %d\n", length(platform_participants)))
  
  if(nrow(platform_data) > 0) {
    # Create heatmap for this platform
    platform_heatmap <- platform_data %>%
      # Add completion status colors to participant labels
      mutate(
        participant_label = paste0(RANDOM_ID, " (", str_extract(study_completion_status, "^[üü°‚úÖüî¥‚ùì]"), ")")
      ) %>%
      # Sort by completion status for better visualization
      arrange(status_category, RANDOM_ID) %>%
      mutate(participant_label = factor(participant_label, levels = unique(participant_label))) %>%
      ggplot(aes(x = study_day, y = participant_label, fill = has_data)) +
      geom_tile(color = "white", size = 0.1) +
      scale_fill_manual(
        values = c("FALSE" = "#f7f7f7", "TRUE" = "#2166ac"),
        labels = c("No Data", "Has Data"),
        name = "Data Status"
      ) +
      scale_x_continuous(breaks = seq(1, 28, 2)) +
      labs(
        title = paste("App Usage Data Availability by Study Day -", stringr::str_to_title(platform)),
        x = "Study Day",
        y = "Participant ID (Completion Status)",
        caption = paste0("Blue = Data available, Gray = No data. ", stringr::str_to_title(platform), " platform only (", 
                        length(platform_participants), " participants).\nParticipants sorted by completion status: üü° In Progress, ‚úÖ Complete, üî¥ Incomplete.")
      ) +
      theme_minimal() +
      theme(
        axis.text.y = element_text(size = 8),
        axis.text.x = element_text(size = 10),
        plot.title = element_text(size = 14, face = "bold"),
        plot.subtitle = element_text(size = 11),
        legend.position = "bottom"
      )
    
    print(platform_heatmap)
  } else {
    cat("No data available for this platform.\n")
  }
}

# Combined heatmap with platform faceting
combined_heatmap <- complete_grid %>%
  # Add completion status colors to participant labels
  mutate(
    participant_label = paste0(RANDOM_ID, " (", str_extract(study_completion_status, "^[üü°‚úÖüî¥‚ùì]"), ")"),
    platform = stringr::str_to_title(platform)
  ) %>%
  # Sort by completion status for better visualization
  arrange(platform, status_category, RANDOM_ID) %>%
  mutate(participant_label = factor(participant_label, levels = unique(participant_label))) %>%
  ggplot(aes(x = study_day, y = participant_label, fill = has_data)) +
  geom_tile(color = "white", size = 0.1) +
  scale_fill_manual(
    values = c("FALSE" = "#f7f7f7", "TRUE" = "#2166ac"),
    labels = c("No Data", "Has Data"),
    name = "Data Status"
  ) +
  scale_x_continuous(breaks = seq(1, 28, 4)) +
  facet_wrap(~ platform, scales = "free_y", ncol = 1) +
  labs(
    title = "App Usage Data Availability by Study Day and Platform",
    x = "Study Day",
    y = "Participant ID (Completion Status)",
    caption = "Blue = Data available, Gray = No data. Participants sorted by completion status within each platform."
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 7),
    axis.text.x = element_text(size = 10),
    plot.title = element_text(size = 14, face = "bold"),
    strip.text = element_text(size = 12, face = "bold"),
    legend.position = "bottom"
  )

cat("\n=== COMBINED PLATFORM HEATMAP ===\n")
print(combined_heatmap)
```

## Gaming Time Series Analysis

```{r gaming-timeseries}
# Calculate daily gaming duration for each participant by platform
gaming_timeseries <- complete_grid %>%
  mutate(
    gaming_duration = ifelse(is.na(gaming_duration), 0, gaming_duration),
    gaming_duration_min = gaming_duration  # Data is already in minutes
  )

# Only filter out participants without Condition data if they exist, otherwise keep all
if(sum(is.na(gaming_timeseries$Condition)) < nrow(gaming_timeseries)) {
  gaming_timeseries <- gaming_timeseries %>%
    filter(!is.na(Condition))
  cat("Filtered to participants with Condition data\n")
} else {
  cat("Warning: All participants missing Condition data - keeping all participants\n")
}

# Check gaming data by platform
gaming_by_platform_summary <- gaming_timeseries %>%
  group_by(platform) %>%
  summarise(
    total_gaming_time = sum(gaming_duration_min, na.rm = TRUE),
    gaming_entries = sum(gaming_duration_min > 0, na.rm = TRUE),
    participants = n_distinct(RANDOM_ID),
    .groups = "drop"
  )

cat("Gaming time summary by platform:\n")
print(gaming_by_platform_summary)

# Overall gaming check
total_gaming_time <- sum(gaming_timeseries$gaming_duration_min, na.rm = TRUE)
cat("\nTotal gaming time across all participants and platforms:", total_gaming_time, "minutes\n")

# Show sample of gaming data by platform
for(platform in platform_types) {
  platform_gaming <- gaming_timeseries %>%
    filter(platform == platform & gaming_duration_min > 0) %>%
    head(5)
  
  if(nrow(platform_gaming) > 0) {
    cat(sprintf("\nSample %s gaming entries:\n", platform))
    print(platform_gaming %>% select(RANDOM_ID, platform, study_day, gaming_duration_min, Condition))
  }
}

# Only create plots if we have gaming data
if(total_gaming_time > 0) {
  # Create separate time series plots for each platform
  for(platform in platform_types) {
    platform_gaming_data <- gaming_timeseries %>% filter(platform == platform)
    platform_gaming_time <- sum(platform_gaming_data$gaming_duration_min, na.rm = TRUE)
    
    cat(sprintf("\n=== %s GAMING TIME SERIES ===\n", toupper(platform)))
    
    if(platform_gaming_time > 0) {
      # Find participants with gaming data for this platform
      participants_with_gaming_platform <- platform_gaming_data %>%
        group_by(RANDOM_ID) %>%
        summarise(total_gaming = sum(gaming_duration_min, na.rm = TRUE)) %>%
        filter(total_gaming > 0) %>%
        pull(RANDOM_ID)
      
      cat(sprintf("Participants with %s gaming data: %d\n", platform, length(participants_with_gaming_platform)))
      
      if(length(participants_with_gaming_platform) > 0) {
        # Prepare data for plotting
        gaming_plot_data <- platform_gaming_data %>%
          filter(RANDOM_ID %in% participants_with_gaming_platform) %>%
          mutate(
            plot_condition = ifelse(is.na(Condition), "Unknown", as.character(Condition)),
            plot_color = case_when(
              is.na(Condition) ~ RANDOM_ID,
              TRUE ~ as.character(Condition)
            )
          )
        
        # Check for NA conditions
        has_na_conditions <- any(is.na(gaming_plot_data$Condition))
        
        if(has_na_conditions) {
          na_participants <- unique(gaming_plot_data$RANDOM_ID[is.na(gaming_plot_data$Condition)])
          base_colors <- c("control" = "#d73027", "intervention" = "#1a9850")
          
          if(length(na_participants) > 0) {
            na_colors <- rainbow(length(na_participants), start = 0.3, end = 0.8)
            names(na_colors) <- na_participants
            all_colors <- c(base_colors, na_colors)
          } else {
            all_colors <- base_colors
          }
          
          platform_gaming_plot <- gaming_plot_data %>%
            ggplot(aes(x = study_day, y = gaming_duration_min, color = plot_color)) +
            geom_line(aes(group = RANDOM_ID), alpha = 0.7, size = 0.8) +
            {if(any(!is.na(gaming_plot_data$Condition))) {
              geom_smooth(data = gaming_plot_data %>% filter(!is.na(Condition)), 
                         aes(color = Condition), method = "loess", se = TRUE, size = 1.5, alpha = 0.7)
            }} +
            scale_x_continuous(breaks = seq(1, 28, 2)) +
            scale_color_manual(values = all_colors, name = "Condition/Participant") +
            labs(
              title = paste("Gaming Duration Time Series -", stringr::str_to_title(platform)),
              x = "Study Day",
              y = "Gaming Duration (minutes)",
              caption = paste0("Individual trajectories for ", stringr::str_to_title(platform), " platform. Based on ", length(participants_with_gaming_platform), " participants.")
            ) +
            theme_minimal() +
            theme(legend.position = "bottom")
          
        } else {
          platform_gaming_plot <- gaming_plot_data %>%
            ggplot(aes(x = study_day, y = gaming_duration_min, color = Condition)) +
            geom_line(aes(group = RANDOM_ID), alpha = 0.3, size = 0.5) +
            geom_smooth(method = "loess", se = TRUE, size = 1.5, alpha = 0.7) +
            scale_x_continuous(breaks = seq(1, 28, 2)) +
            scale_color_manual(values = c("control" = "#d73027", "intervention" = "#1a9850")) +
            labs(
              title = paste("Gaming Duration Time Series -", stringr::str_to_title(platform)),
              x = "Study Day",
              y = "Gaming Duration (minutes)",
              color = "Condition",
              caption = paste0("Individual trajectories (thin lines) with smoothed averages (thick lines) for ", stringr::str_to_title(platform), " platform.\nBased on ", length(participants_with_gaming_platform), " participants.")
            ) +
            theme_minimal() +
            theme(legend.position = "bottom")
        }
        
        print(platform_gaming_plot)
      } else {
        cat(sprintf("No participants found with %s gaming data.\n", platform))
      }
    } else {
      cat(sprintf("No gaming time recorded for %s platform.\n", platform))
    }
  }
  
  # Combined plot with platform faceting
  participants_with_gaming <- gaming_timeseries %>%
    group_by(RANDOM_ID, platform) %>%
    summarise(total_gaming = sum(gaming_duration_min, na.rm = TRUE), .groups = "drop") %>%
    filter(total_gaming > 0)
  
  if(nrow(participants_with_gaming) > 0) {
    cat("\n=== COMBINED GAMING TIME SERIES BY PLATFORM ===\n")
    
    combined_gaming_plot <- gaming_timeseries %>%
      filter(paste(RANDOM_ID, platform) %in% paste(participants_with_gaming$RANDOM_ID, participants_with_gaming$platform)) %>%
      mutate(platform = stringr::str_to_title(platform)) %>%
      ggplot(aes(x = study_day, y = gaming_duration_min, color = Condition)) +
      geom_line(aes(group = RANDOM_ID), alpha = 0.4, size = 0.5) +
      geom_smooth(method = "loess", se = TRUE, size = 1.2, alpha = 0.7) +
      scale_x_continuous(breaks = seq(1, 28, 4)) +
      scale_color_manual(values = c("control" = "#d73027", "intervention" = "#1a9850")) +
      facet_wrap(~ platform, scales = "free_y", ncol = 1) +
      labs(
        title = "Gaming Duration Time Series by Platform and Condition",
        x = "Study Day",
        y = "Gaming Duration (minutes)",
        color = "Condition",
        caption = "Individual participant trajectories with smoothed condition averages, separated by platform."
      ) +
      theme_minimal() +
      theme(
        legend.position = "bottom",
        strip.text = element_text(size = 12, face = "bold")
      )
    
    print(combined_gaming_plot)
  }
} else {
  cat("No gaming data found. Skipping gaming time series plots.\n")
}
```

## Gaming Apps Analysis

```{r gaming-apps-analysis}
# Identify and analyze gaming apps - showing ALL gaming apps with participant counts
gaming_apps_summary <- aw_processed %>%
  filter(ProbGame == TRUE) %>%
  group_by(App) %>%
  summarise(
    participant_count = n_distinct(RANDOM_ID),
    total_sessions = n(),
    total_duration = sum(Duration, na.rm = TRUE),
    unique_days = n_distinct(session_date),
    avg_duration_per_session = mean(Duration, na.rm = TRUE),
    avg_confidence = mean(LLM_conf, na.rm = TRUE),
    platforms = paste(sort(unique(platform)), collapse = ", "),
    .groups = "drop"
  ) %>%
  arrange(desc(participant_count), desc(total_duration)) %>%
  mutate(
    total_duration_hours = round(total_duration / 60, 1),
    avg_duration_per_session = round(avg_duration_per_session, 1),
    avg_confidence = round(avg_confidence, 1)
  )

# Display stats
if(nrow(gaming_apps_summary) > 0) {
  cat("Total unique gaming apps identified:", nrow(gaming_apps_summary), "\n")
  cat("Apps played by 1 participant:", sum(gaming_apps_summary$participant_count == 1), "\n")
  cat("Apps played by 2+ participants:", sum(gaming_apps_summary$participant_count >= 2), "\n")
  cat("Apps played by 5+ participants:", sum(gaming_apps_summary$participant_count >= 5), "\n\n")
  
  datatable(gaming_apps_summary,
            caption = "All Gaming Apps Summary (with Participant Counts)",
            colnames = c("App Name", "Participants", "Total Sessions", "Total Duration (min)", 
                         "Days Used", "Avg Duration/Session (min)", "Avg LLM Confidence", 
                         "Platforms", "Total Duration (hrs)"),
            options = list(
              pageLength = 20,
              scrollX = TRUE,
              columnDefs = list(list(width = '150px', targets = c(0))),
              order = list(list(1, 'desc'), list(3, 'desc'))
            ),
            filter = 'top') %>%
            formatRound(columns = c(3, 5, 6, 7, 9), digits = 1)
} else {
  cat("No gaming apps found.\n")
}

# Top gaming apps by participant
top_gaming_by_participant <- aw_processed %>%
  filter(ProbGame == TRUE) %>%
  group_by(RANDOM_ID, App) %>%
  summarise(
    total_sessions = n(),
    total_duration = sum(Duration, na.rm = TRUE),
    days_used = n_distinct(session_date),
    .groups = "drop"
  ) %>%
  group_by(RANDOM_ID) %>%
  arrange(RANDOM_ID, desc(total_duration)) %>%
  mutate(
    app_rank = row_number(),
    pct_of_total_gaming = round((total_duration / sum(total_duration)) * 100, 1)
  ) %>%
  filter(app_rank <= 5) %>%  # Top 5 gaming apps per participant
  ungroup() %>%
  left_join(
    participant_summary %>% select(RANDOM_ID, Condition, study_completion_status),
    by = "RANDOM_ID"
  )

# Show sample of top gaming apps by participant
if(nrow(top_gaming_by_participant) > 0) {
  cat("\nSample of participants' top gaming apps:\n")
  sample_participants <- top_gaming_by_participant %>%
    arrange(RANDOM_ID, app_rank)

  current_participant <- ""
  count <- 0
  for(i in 1:min(nrow(sample_participants), 50)) {  # Show first 50 entries
    row <- sample_participants[i,]
    if (row$RANDOM_ID != current_participant) {
      current_participant <- row$RANDOM_ID
      count <- count + 1
      if(count <= 10) {  # Show first 10 participants
        cat(sprintf("\n%s (%s, %s):\n", row$RANDOM_ID, row$study_completion_status, row$Condition))
      }
    }
    if(count <= 10) {
      cat(sprintf("  %d. %s (%d sessions, %.1f min, %d days, %.1f%%)\n", 
                  row$app_rank, row$App, row$total_sessions, row$total_duration, 
                  row$days_used, row$pct_of_total_gaming))
    }
  }
} else {
  cat("No gaming apps found for individual participants.\n")
}
```

## Data Availability Trends

```{r availability-trends}
# Plot percentage of participants with data by study day
availability_trend <- availability_summary %>%
  ggplot(aes(x = study_day, y = percentage_with_data)) +
  geom_line(color = "#2166ac", size = 1) +
  geom_point(color = "#2166ac", size = 2) +
  scale_x_continuous(breaks = seq(1, 28, 2)) +
  scale_y_continuous(limits = c(0, 100), labels = function(x) paste0(x, "%")) +
  labs(
    title = "Percentage of ActivityWatch Participants with App Usage Data by Study Day",
    x = "Study Day",
    y = "Percentage of Participants with Data",
    caption = paste0("Based on ", n_distinct(aw_processed$RANDOM_ID), " ActivityWatch participants")
  ) +
  theme_minimal()

print(availability_trend)

# Additional summary statistics
cat("\nData Availability Statistics:\n")
cat("- Days with 100% participation:", sum(availability_summary$percentage_with_data == 100), "\n")
cat("- Days with >50% participation:", sum(availability_summary$percentage_with_data > 50), "\n")
cat("- Days with <25% participation:", sum(availability_summary$percentage_with_data < 25), "\n")
```

## Individual Participant Patterns

```{r individual-patterns}
# Look at individual participant data patterns
participant_patterns <- complete_grid %>%
  group_by(RANDOM_ID, Condition, study_completion_status, status_category) %>%
  summarise(
    total_days_with_data = sum(has_data),
    consecutive_days = max(rle(has_data)$lengths[rle(has_data)$values == TRUE], na.rm = TRUE),
    first_day_with_data = min(study_day[has_data], na.rm = TRUE),
    last_day_with_data = max(study_day[has_data], na.rm = TRUE),
    total_gaming_duration = sum(gaming_duration, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    consecutive_days = ifelse(is.infinite(consecutive_days), 0, consecutive_days),
    data_span = last_day_with_data - first_day_with_data + 1,
    avg_gaming_per_day = round(total_gaming_duration / pmax(1, total_days_with_data), 1)
  ) %>%
  # Sort by completion status
  arrange(status_category, RANDOM_ID)

# Summary by condition
pattern_summary <- participant_patterns %>%
  group_by(Condition) %>%
  summarise(
    n_participants = n(),
    avg_days_with_data = mean(total_days_with_data, na.rm = TRUE),
    median_days_with_data = median(total_days_with_data, na.rm = TRUE),
    avg_consecutive_days = mean(consecutive_days, na.rm = TRUE),
    avg_gaming_duration = mean(total_gaming_duration, na.rm = TRUE),
    .groups = "drop"
  )

cat("ActivityWatch Participant Data Patterns by Condition:\n")
datatable(pattern_summary,
          caption = "ActivityWatch Participant Data Patterns Summary by Condition",
          colnames = c("Condition", "Participants", "Avg Days with Data", "Median Days with Data", 
                       "Avg Consecutive Days", "Avg Total Gaming Duration (min)"),
          options = list(
            pageLength = 10,
            scrollX = TRUE,
            order = list(list(0, 'asc'))
          ),
          filter = 'top') %>%
          formatRound(columns = c(3, 4, 5, 6), digits = 1)

# Interactive detailed participant table
datatable(participant_patterns, 
      caption = "Individual ActivityWatch Participant Data Patterns (Sorted by Completion Status)",
      options = list(
        pageLength = 20,
        scrollX = TRUE,
        columnDefs = list(list(width = '100px', targets = c(0, 1, 2, 3))),
        order = list(list(2, 'asc'))
      ),
      filter = 'top') %>%
      formatRound(columns = c(5, 6, 7, 8, 9, 10, 11), digits = 1)
```

## Key Findings Summary

```{r summary}
# Calculate key statistics
total_aw_participants <- n_distinct(aw_processed$RANDOM_ID)
days_with_any_data <- sum(availability_summary$participants_with_data > 0)
peak_participation_day <- availability_summary$study_day[which.max(availability_summary$percentage_with_data)]
peak_participation_rate <- max(availability_summary$percentage_with_data)

avg_days_per_participant <- mean(participant_patterns$total_days_with_data, na.rm = TRUE)
participants_with_full_study <- sum(participant_patterns$total_days_with_data >= 20, na.rm = TRUE)

# Gaming statistics
total_gaming_apps <- n_distinct(aw_processed$App[aw_processed$ProbGame == TRUE])
avg_gaming_duration <- mean(participant_patterns$total_gaming_duration, na.rm = TRUE)

# Completion status counts
completion_counts <- participant_summary %>% count(study_completion_status)
in_progress <- completion_counts$n[completion_counts$study_completion_status == "üü° In Progress"]
complete <- completion_counts$n[completion_counts$study_completion_status == "‚úÖ Complete"]
incomplete <- completion_counts$n[completion_counts$study_completion_status == "üî¥ Incomplete"]

# Handle NA values for missing statuses
in_progress <- ifelse(length(in_progress) == 0, 0, in_progress)
complete <- ifelse(length(complete) == 0, 0, complete)
incomplete <- ifelse(length(incomplete) == 0, 0, incomplete)

cat("=== ACTIVITYWATCH APP USAGE KEY FINDINGS ===\n\n")
cat("Study Overview:\n")
cat("- Total ActivityWatch participants with app usage data:", total_aw_participants, "\n")
cat("- Report generated on:", as.character(Sys.Date()), "\n")
cat("- Study days with any data:", days_with_any_data, "out of 28\n")
cat("- Peak participation on day", peak_participation_day, "with", round(peak_participation_rate, 1), "% of participants\n\n")

cat("Study Completion Status:\n")
cat("- üü° In Progress (not yet 28 days since enrollment):", in_progress, "participants\n")
cat("- ‚úÖ Complete (‚â•28 days, ‚â•20 days of data):", complete, "participants\n")
cat("- üî¥ Incomplete (‚â•28 days, <20 days of data):", incomplete, "participants\n\n")

cat("Data Coverage:\n")
cat("- Average days with data per participant:", round(avg_days_per_participant, 1), "\n")
cat("- Participants with data for ‚â•20 days:", participants_with_full_study, "out of", total_aw_participants, "\n")
cat("- Overall data availability rate:", round(mean(availability_summary$percentage_with_data), 1), "%\n\n")

cat("Gaming Analysis:\n")
cat("- Unique gaming apps identified:", total_gaming_apps, "\n")
cat("- Average total gaming duration per participant:", round(avg_gaming_duration, 1), "minutes\n")
if(exists("gaming_apps_summary") && nrow(gaming_apps_summary) > 0) {
  cat("- Gaming apps used by ‚â•2 participants:", nrow(gaming_apps_summary), "\n")
}
cat("\n")

cat("Platform Comparison:\n")
for(platform in platform_types) {
  platform_participants <- gaming_by_platform_summary$participants[gaming_by_platform_summary$platform == platform]
  platform_gaming <- gaming_by_platform_summary$total_gaming_time[gaming_by_platform_summary$platform == platform]
  cat(sprintf("- %s platform: %d participants, %.0f min total gaming\n", 
              stringr::str_to_title(platform), 
              ifelse(length(platform_participants) > 0, platform_participants, 0),
              ifelse(length(platform_gaming) > 0, platform_gaming, 0)))
}

cat("\nCondition Comparison:\n")
control_avg <- pattern_summary$avg_days_with_data[pattern_summary$Condition == "control"]
intervention_avg <- pattern_summary$avg_days_with_data[pattern_summary$Condition == "intervention"]
control_gaming <- pattern_summary$avg_gaming_duration[pattern_summary$Condition == "control"]
intervention_gaming <- pattern_summary$avg_gaming_duration[pattern_summary$Condition == "intervention"]

if(length(control_avg) > 0) cat("- Control group average days:", round(control_avg, 1), "\n")
if(length(intervention_avg) > 0) cat("- Intervention group average days:", round(intervention_avg, 1), "\n")
if(length(control_gaming) > 0) cat("- Control group average gaming duration:", round(control_gaming, 1), "min\n")
if(length(intervention_gaming) > 0) cat("- Intervention group average gaming duration:", round(intervention_gaming, 1), "min\n")
```

## Data Export

```{r export}
# Create output directory if it doesn't exist
if (!dir.exists("../../.tmp/aw")) {
  dir.create("../../.tmp/aw", recursive = TRUE)
}

# Export processed data for further analysis
write_csv(complete_grid, "../../.tmp/aw/study_day_availability_matrix.csv")
write_csv(availability_summary, "../../.tmp/aw/daily_availability_summary.csv")
write_csv(participant_patterns, "../../.tmp/aw/participant_data_patterns.csv")
write_csv(gaming_timeseries, "../../.tmp/aw/gaming_timeseries_data.csv")

if(exists("gaming_apps_summary") && nrow(gaming_apps_summary) > 0) {
  write_csv(gaming_apps_summary, "../../.tmp/aw/gaming_apps_summary.csv")
}

if(exists("top_gaming_by_participant") && nrow(top_gaming_by_participant) > 0) {
  write_csv(top_gaming_by_participant, "../../.tmp/aw/top_gaming_apps_by_participant.csv")
}

cat("Exported ActivityWatch analysis files:\n")
cat("- study_day_availability_matrix.csv: Complete participant x study day matrix\n")
cat("- daily_availability_summary.csv: Daily availability percentages\n")
cat("- participant_data_patterns.csv: Individual participant patterns\n")
cat("- gaming_timeseries_data.csv: Gaming duration time series data\n")
if(exists("gaming_apps_summary") && nrow(gaming_apps_summary) > 0) {
  cat("- gaming_apps_summary.csv: Gaming apps usage statistics\n")
}
if(exists("top_gaming_by_participant") && nrow(top_gaming_by_participant) > 0) {
  cat("- top_gaming_apps_by_participant.csv: Top gaming apps per participant\n")
}
```