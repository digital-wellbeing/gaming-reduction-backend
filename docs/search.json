[
  {
    "objectID": "scripts/sim_comp_report.html",
    "href": "scripts/sim_comp_report.html",
    "title": "3  Simulation-based Power Analysis for Two-arm RCT with Compositional Outcomes",
    "section": "",
    "text": "3.1 Introduction\nThis document demonstrates a simulation-based power analysis for a two-arm parallel randomized controlled trial (RCT) with compositional outcomes. The simulation models 24-hour time use data consisting of three components: sleep, sedentary time, and physical activity, which sum to 1440 minutes (24 hours). The analysis includes visualization of power curves and effect sizes to help determine optimal sample sizes and assess the sensitivity of the study design to different parameters.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Simulation-based Power Analysis for Two-arm RCT with Compositional Outcomes</span>"
    ]
  },
  {
    "objectID": "scripts/sim_comp_report.html#required-packages",
    "href": "scripts/sim_comp_report.html#required-packages",
    "title": "3  Simulation-based Power Analysis for Two-arm RCT with Compositional Outcomes",
    "section": "3.2 Required Packages",
    "text": "3.2 Required Packages\n\n\nCode\n# Install required packages if not already installed\nreq &lt;- c(\"tidyverse\", \"lme4\", \"compositions\", \"ggtern\", \"progress\", \"phyloseq\", \"patchwork\", \"lmerTest\", \"foreach\", \"doSNOW\", \"doParallel\")\nneed &lt;- req[!req %in% installed.packages()[, \"Package\"]]\nif (length(need)) install.packages(need)\n\n# Install Bioconductor packages if needed\nif (!requireNamespace(\"BiocManager\", quietly = TRUE)) install.packages(\"BiocManager\")\nbioc_pkgs &lt;- c(\"phyloseq\", \"microbiome\", \"ComplexHeatmap\")\nbioc_need &lt;- bioc_pkgs[!bioc_pkgs %in% installed.packages()[, \"Package\"]]\nif (length(bioc_need)) BiocManager::install(bioc_need, update = FALSE)\n\n# Install microViz from R Universe only if not already installed\nif (!\"microViz\" %in% installed.packages()[, \"Package\"]) {\n  install.packages(\n    \"microViz\",\n    repos = c(davidbarnett = \"https://david-barnett.r-universe.dev\", getOption(\"repos\"))\n  )\n}\n\n# Install suggested packages for enhanced microViz functionality\nsuggested &lt;- c(\"ggtext\", \"ggraph\", \"DT\", \"corncob\")\nneed_suggested &lt;- suggested[!suggested %in% installed.packages()[, \"Package\"]]\nif (length(need_suggested)) install.packages(need_suggested)\n\n# Load all required packages\ninvisible(lapply(c(req, \"microViz\"), library, character.only = TRUE))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Simulation-based Power Analysis for Two-arm RCT with Compositional Outcomes</span>"
    ]
  },
  {
    "objectID": "scripts/sim_comp_report.html#helper-functions",
    "href": "scripts/sim_comp_report.html#helper-functions",
    "title": "3  Simulation-based Power Analysis for Two-arm RCT with Compositional Outcomes",
    "section": "3.3 Helper Functions",
    "text": "3.3 Helper Functions\nThese functions convert between compositional data and isometric log-ratio (ilr) coordinates.\n\n\nCode\ncomp_to_ilr &lt;- function(x_min) {\n  stopifnot(is.matrix(x_min), ncol(x_min) == 3)\n  bad_row &lt;- !is.finite(rowSums(x_min)) | rowSums(x_min) &lt;= 0\n  if (any(bad_row)) {\n    x_min[bad_row, ] &lt;- matrix(rep(c(600, 480, 360), each = sum(bad_row)), ncol = 3, byrow = TRUE)\n  }\n  x_min[x_min &lt;= 0 | !is.finite(x_min)] &lt;- 1e-6\n  compositions::ilr(sweep(x_min, 1, rowSums(x_min), \"/\"))\n}\n\nilr_to_minutes &lt;- function(ilr_mat, total = 1440) {\n  stopifnot(is.matrix(ilr_mat), ncol(ilr_mat) == 2)\n  comp_obj &lt;- compositions::ilrInv(ilr_mat)\n  prop &lt;- as.data.frame(comp_obj)\n  prop &lt;- as.matrix(prop)\n  \n  bad &lt;- apply(prop, 1, function(r) any(!is.finite(r) | r &lt;= 0) ||\n                                   !is.finite(sum(r)) || abs(sum(r) - 1) &gt; 1e-8)\n  if (any(bad)) prop[bad, ] &lt;- 1/3\n  round(prop * total, 1)\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Simulation-based Power Analysis for Two-arm RCT with Compositional Outcomes</span>"
    ]
  },
  {
    "objectID": "scripts/sim_comp_report.html#simulation-engine",
    "href": "scripts/sim_comp_report.html#simulation-engine",
    "title": "3  Simulation-based Power Analysis for Two-arm RCT with Compositional Outcomes",
    "section": "3.4 Simulation Engine",
    "text": "3.4 Simulation Engine\n\n\nCode\n# Power estimation using SimEngine – cleaned version (no play_sd_prop, no corr_noise_sd)\n\n# Install SimEngine if not already installed\nif (!requireNamespace(\"SimEngine\", quietly = TRUE)) {\n  install.packages(\"SimEngine\")\n}\n\n# Load required packages\nlibrary(SimEngine)\nlibrary(lme4)\nlibrary(lmerTest)\nlibrary(compositions)\nlibrary(MASS)\nlibrary(dplyr)\n\n# --------------------------------------------------------------------------------\n# Command line argument parsing ---------------------------------------------------\n# --------------------------------------------------------------------------------\n# Parse command line arguments for flexible parameter adjustment\nargs &lt;- commandArgs(trailingOnly = TRUE)\n\n# Default values\ndefault_sims &lt;- 10\ndefault_cores &lt;- 16\n\n# Parse arguments: --sims=VALUE --cores=VALUE\nsims_param &lt;- default_sims\ncores_param &lt;- default_cores\n\nif (length(args) &gt; 0) {\n  for (arg in args) {\n    if (grepl(\"^--sims=\", arg)) {\n      sims_param &lt;- as.numeric(sub(\"^--sims=\", \"\", arg))\n      if (is.na(sims_param) || sims_param &lt;= 0) {\n        warning(\"Invalid sims parameter, using default: \", default_sims)\n        sims_param &lt;- default_sims\n      }\n    } else if (grepl(\"^--cores=\", arg)) {\n      cores_param &lt;- as.numeric(sub(\"^--cores=\", \"\", arg))\n      if (is.na(cores_param) || cores_param &lt;= 0) {\n        warning(\"Invalid cores parameter, using default: \", default_cores)\n        cores_param &lt;- default_cores\n      }\n    }\n  }\n}\n\n# Log the parameters being used\nmessage(\"=== SIMULATION PARAMETERS ===\")\nmessage(\"Number of simulations: \", sims_param)\nmessage(\"Number of cores: \", cores_param)\nmessage(\"==============================\")\n\n# --------------------------------------------------------------------------------\n# Main simulation wrapper ---------------------------------------------------------\n# --------------------------------------------------------------------------------\n\nest_power_simengine &lt;- function(n_pg = 50,\n                               effect_min_values = c(30),\n                               s_between_values  = c(0.15),\n                               s_within_values   = c(0.25),\n                               baseline_days     = 7,\n                               intervention_days = 14,\n                               sims              = 500,\n                               cores             = 4) {\n\n  start_time &lt;- Sys.time()\n  message(\"Setting up SimEngine simulation …\")\n\n  # Create simulation object\n  sim &lt;- new_sim()\n\n  # ------------------------------------------------------------------------------\n  # LEVELS (note: no play_sd_prop, no corr_noise_sd) ------------------------------\n  # ------------------------------------------------------------------------------\n  sim %&lt;&gt;% set_levels(\n    n_pg             = n_pg,\n    effect_min       = effect_min_values,\n    s_between        = s_between_values,\n    s_within         = s_within_values,\n    baseline_days    = baseline_days,\n    intervention_days= intervention_days\n  )\n\n  # ------------------------------------------------------------------------------\n  # Helper transformations (INSIDE function for parallel access) ------------------\n  # ------------------------------------------------------------------------------\n  \n  comp_to_ilr &lt;- function(x_min) {\n    stopifnot(is.matrix(x_min), ncol(x_min) == 3)\n    bad_row &lt;- !is.finite(rowSums(x_min)) | rowSums(x_min) &lt;= 0\n    if (any(bad_row)) {\n      x_min[bad_row, ] &lt;- matrix(rep(c(600, 480, 360), each = sum(bad_row)), ncol = 3, byrow = TRUE)\n    }\n    x_min[x_min &lt;= 0 | !is.finite(x_min)] &lt;- 1e-6\n    compositions::ilr(sweep(x_min, 1, rowSums(x_min), \"/\"))\n  }\n\n  ilr_to_minutes &lt;- function(ilr_mat, total = 1440) {\n    stopifnot(is.matrix(ilr_mat), ncol(ilr_mat) == 2)\n    comp_obj &lt;- compositions::ilrInv(ilr_mat)\n    prop &lt;- as.matrix(as.data.frame(comp_obj))\n    bad &lt;- apply(prop, 1, function(r) any(!is.finite(r) | r &lt;= 0) ||\n                   !is.finite(sum(r)) || abs(sum(r) - 1) &gt; 1e-8)\n    if (any(bad)) prop[bad, ] &lt;- 1/3\n    round(prop * total, 1)\n  }\n\n  # ------------------------------------------------------------------------------\n  # Data‑generating function ------------------------------------------------------\n  # ------------------------------------------------------------------------------\n  generate_data &lt;- function(n_pg, effect_min, baseline_days, intervention_days,\n                            s_between, s_within, seed = NULL) {\n\n    if (!is.null(seed)) set.seed(seed)\n\n    N   &lt;- n_pg * 2\n    grp &lt;- rep(0:1, each = n_pg)              # 0 = Control, 1 = Intervention\n\n    # Mean daily compositions: (sedentary, sleep, physical)\n    base_comp   &lt;- c(600, 480, 360)\n    active_comp &lt;- c(600 - effect_min, 480, 360 + effect_min)\n\n    # Person‑level random effects in ILR space\n    b_ilr &lt;- MASS::mvrnorm(N, mu = c(0, 0), Sigma = diag(s_between^2, 2))\n\n    # Person-specific playtime proportion of sedentary time (10-40%)\n    personal_play_prop &lt;- sapply(1:N, function(i) {\n      p &lt;- rbeta(1, 2, 5) * 0.3 + 0.1  # right-skew between 0.1-0.4\n      return(p)\n    })\n\n    # Containers\n    all_ids &lt;- all_periods &lt;- all_days &lt;- NULL\n    all_ilr &lt;- matrix(, 0, 2)\n    all_sedentary &lt;- numeric()  # Store actual sedentary minutes\n\n    for (i in seq_len(N)) {\n      for (period in c(\"baseline\", \"intervention\")) {\n        ndays   &lt;- if (period == \"baseline\") baseline_days else intervention_days\n        comp_mu &lt;- if (period == \"baseline\" || grp[i] == 0) base_comp else active_comp\n\n        comp_ilr &lt;- comp_to_ilr(matrix(rep(comp_mu, ndays), ncol = 3, byrow = TRUE))\n        comp_ilr &lt;- sweep(comp_ilr, 2, b_ilr[i, ], \"+\")               # add person RE\n        day_ilr  &lt;- comp_ilr + MASS::mvrnorm(ndays, mu = c(0, 0),\n                                             Sigma = diag(s_within^2, 2))\n\n        # Index bookkeeping\n        all_ids     &lt;- c(all_ids, rep(i, ndays))\n        all_periods &lt;- c(all_periods, rep(period, ndays))\n        all_days    &lt;- c(all_days,\n                         if (period == \"baseline\") seq_len(baseline_days)\n                         else baseline_days + seq_len(intervention_days))\n        all_ilr     &lt;- rbind(all_ilr, day_ilr)\n        \n        # Store sedentary minutes for this person-period (will be calculated after ILR transformation)\n        # We'll calculate playtime after we have the actual sedentary minutes\n      }\n    }\n\n    # Back‑transform ILR → minutes and calculate playtime based on actual sedentary behavior\n    mins &lt;- ilr_to_minutes(all_ilr)\n    colnames(mins) &lt;- c(\"sedentary\", \"sleep\", \"physical\")\n    \n    # Now generate playtime based on actual sedentary minutes\n    playmin &lt;- numeric(length(all_ids))\n    \n    for (i in seq_along(all_ids)) {\n      person_id &lt;- all_ids[i]\n      period &lt;- all_periods[i]\n      actual_sedentary &lt;- mins[i, \"sedentary\"]\n      \n      # Base playtime as proportion of actual sedentary time\n      base_playtime &lt;- personal_play_prop[person_id] * actual_sedentary\n      \n      # Add small amount of day-to-day noise (2% of base playtime)\n      daily_sd &lt;- 0.02 * base_playtime\n      noisy_playtime &lt;- rnorm(1, base_playtime, daily_sd)\n      \n      # Apply intervention effect for intervention group during intervention period\n      if (period == \"intervention\" && grp[person_id] == 1) {\n        # Reduce playtime by effect_min, but ensure it doesn't go below 0\n        # The reduction is additive (in minutes) to maintain the intended effect size\n        intervention_playtime &lt;- pmax(0, noisy_playtime - effect_min)\n        playmin[i] &lt;- intervention_playtime\n      } else {\n        # Control group or baseline period: just use the playtime based on actual sedentary\n        playmin[i] &lt;- pmax(0, noisy_playtime)  # Ensure non-negative\n      }\n    }\n\n    # Assemble data frame\n    dat &lt;- data.frame(\n      id        = factor(all_ids),\n      group     = factor(grp[all_ids], labels = c(\"Control\", \"Abstinence\")),\n      period    = factor(all_periods, levels = c(\"baseline\", \"intervention\")),\n      day       = all_days,\n      sedentary = mins[, 1],\n      sleep     = mins[, 2],\n      physical  = mins[, 3],\n      playtime  = playmin\n    )\n\n    dat &lt;- dat %&gt;%\n      group_by(id) %&gt;%\n      mutate(\n        base_play_mean      = mean(playtime[period == \"baseline\"]),\n        playtime_reduction  = base_play_mean - playtime,\n        intervention_active = as.integer(group == \"Abstinence\" & period == \"intervention\")\n      ) %&gt;%\n      ungroup()\n\n    return(dat)\n  }\n\n  # ------------------------------------------------------------------------------\n  # Analysis function -------------------------------------------------------------\n  # ------------------------------------------------------------------------------\n  run_analysis &lt;- function(data) {\n    data_ilr &lt;- data\n    comp_matrix &lt;- as.matrix(data[, c(\"sedentary\", \"sleep\", \"physical\")])\n    ilr_coords  &lt;- comp_to_ilr(comp_matrix)\n    data_ilr$ilr1 &lt;- ilr_coords[, 1]\n\n    results &lt;- list()\n\n    ## Between‑group effect during intervention ----------------------------------\n    md &lt;- subset(data_ilr, period == \"intervention\")\n    mb &lt;- try(lmer(ilr1 ~ group + (1 | id), data = md), silent = TRUE)\n    results$p_between &lt;- if (!inherits(mb, \"try-error\")) anova(mb)[\"group\", \"Pr(&gt;F)\"] else NA\n\n    ## Within‑group effects -------------------------------------------------------\n    mc &lt;- try(lmer(ilr1 ~ period + (1 | id), data = subset(data_ilr, group == \"Control\")), silent = TRUE)\n    results$p_control &lt;- if (!inherits(mc, \"try-error\")) anova(mc)[\"period\", \"Pr(&gt;F)\"] else NA\n\n    mi &lt;- try(lmer(ilr1 ~ period + (1 | id), data = subset(data_ilr, group == \"Abstinence\")), silent = TRUE)\n    results$p_intervention &lt;- if (!inherits(mi, \"try-error\")) anova(mi)[\"period\", \"Pr(&gt;F)\"] else NA\n\n    ## Interaction ----------------------------------------------------------------\n    mx &lt;- try(lmer(ilr1 ~ group * period + (1 | id), data = data_ilr), silent = TRUE)\n    results$p_interaction &lt;- if (!inherits(mx, \"try-error\")) anova(mx)[\"group:period\", \"Pr(&gt;F)\"] else NA\n\n    ## Per‑protocol contrast ------------------------------------------------------\n    mp &lt;- try(lmer(ilr1 ~ intervention_active * playtime_reduction + (1 | id), data = data_ilr), silent = TRUE)\n    results$p_protocol &lt;- if (!inherits(mp, \"try-error\")) anova(mp)[\"intervention_active:playtime_reduction\", \"Pr(&gt;F)\"] else NA\n\n    return(results)\n  }\n\n  # ------------------------------------------------------------------------------\n  # Simulation script ------------------------------------------------------------\n  # ------------------------------------------------------------------------------\n  sim %&lt;&gt;% set_script(function() {\n    set.seed(sample.int(1e7, 1))\n    \n    # Access simulation level variables correctly\n    data &lt;- generate_data(\n      n_pg             = L$n_pg,\n      effect_min       = L$effect_min,\n      baseline_days    = L$baseline_days,\n      intervention_days= L$intervention_days,\n      s_between        = L$s_between,\n      s_within         = L$s_within\n    )\n    \n    # Run analysis and ensure proper error handling\n    result &lt;- tryCatch({\n      run_analysis(data)\n    }, error = function(e) {\n      # Return NA values with proper names if analysis fails\n      list(\n        p_between = NA_real_, \n        p_control = NA_real_, \n        p_intervention = NA_real_,\n        p_interaction = NA_real_, \n        p_protocol = NA_real_\n      )\n    })\n    \n    # Ensure result is a proper list with all required elements\n    if (!is.list(result)) {\n      result &lt;- list(\n        p_between = NA_real_, \n        p_control = NA_real_, \n        p_intervention = NA_real_,\n        p_interaction = NA_real_, \n        p_protocol = NA_real_\n      )\n    }\n    \n    # Ensure all required columns exist\n    required_names &lt;- c(\"p_between\", \"p_control\", \"p_intervention\", \"p_interaction\", \"p_protocol\")\n    for (name in required_names) {\n      if (!(name %in% names(result))) {\n        result[[name]] &lt;- NA_real_\n      }\n    }\n    \n    return(result)\n  })\n\n  # ------------------------------------------------------------------------------\n  # Config & run -----------------------------------------------------------------\n  # ------------------------------------------------------------------------------\n  sim %&lt;&gt;% set_config(\n    num_sim      = sims,\n    parallel     = TRUE,   # Enable parallel processing\n    n_cores      = cores,  # Use specified cores\n    packages     = c(\"lme4\", \"lmerTest\", \"compositions\", \"MASS\", \"dplyr\"),\n    progress_bar = TRUE\n  )\n\n  \n  # # Add a test run to debug issues\n  # message(\"Testing data generation and analysis functions...\")\n  # tryCatch({\n  #   test_data &lt;- generate_data(\n  #     n_pg = 10,  # Small test\n  #     effect_min = 30,\n  #     baseline_days = 7,\n  #     intervention_days = 14,\n  #     s_between = 0.15,\n  #     s_within = 0.25\n  #   )\n  #   message(\"✓ Data generation successful\")\n  #   message(\"Test data dimensions: \", nrow(test_data), \" x \", ncol(test_data))\n    \n  #   test_results &lt;- run_analysis(test_data)\n  #   message(\"✓ Analysis function successful\")\n  #   message(\"Test results: \", paste(names(test_results), test_results, sep=\"=\", collapse=\", \"))\n  # }, error = function(e) {\n  #   message(\"❌ Test failed with error: \", e$message)\n  #   stop(\"Stopping due to test failure. Fix the issue before running full simulation.\")\n  # })\n\n  # message(\"Running simulations …\")\n  \n  sim %&lt;&gt;% run()\n\n  # ------------------------------------------------------------------------------\n  # Summarise power --------------------------------------------------------------\n  # ------------------------------------------------------------------------------\n  results &lt;- sim$results\n  \n  # Add debugging information\n  message(\"Debug: Checking simulation results...\")\n  message(\"Results object class: \", class(results))\n  message(\"Results is null: \", is.null(results))\n  if (!is.null(results)) {\n    message(\"Results dimensions: \", nrow(results), \" x \", ncol(results))\n    message(\"Results column names: \", paste(names(results), collapse = \", \"))\n  }\n  \n  # Add error handling for when all simulations fail\n  if (is.null(results) || (is.data.frame(results) && nrow(results) == 0)) {\n    stop(\"All simulations failed. Check your simulation parameters and functions.\")\n  }\n  \n  # Check if required columns exist before processing\n  required_cols &lt;- c(\"p_between\", \"p_control\", \"p_intervention\", \"p_interaction\", \"p_protocol\")\n  missing_cols &lt;- setdiff(required_cols, names(results))\n  if (length(missing_cols) &gt; 0) {\n    stop(paste(\"Missing columns in results:\", paste(missing_cols, collapse = \", \")))\n  }\n  \n  for (col in required_cols) {\n    results[[col]] &lt;- as.numeric(as.character(results[[col]]))\n  }\n\n  power_df &lt;- aggregate(\n    cbind(\n      power_between     = results$p_between     &lt; 0.05,\n      power_control     = results$p_control     &lt; 0.05,\n      power_intervention= results$p_intervention&lt; 0.05,\n      power_interaction = results$p_interaction &lt; 0.05,\n      power_protocol    = results$p_protocol    &lt; 0.05,\n      valid_between     = !is.na(results$p_between),\n      valid_control     = !is.na(results$p_control), \n      valid_intervention= !is.na(results$p_intervention),\n      valid_interaction = !is.na(results$p_interaction),\n      valid_protocol    = !is.na(results$p_protocol)\n    ),\n    by = list(\n      n_pg             = results$n_pg,\n      effect_min       = results$effect_min,\n      s_between        = results$s_between,\n      s_within         = results$s_within,\n      baseline_days    = results$baseline_days,\n      intervention_days= results$intervention_days\n    ),\n    FUN = mean, na.rm = TRUE\n  )\n\n  end_time &lt;- Sys.time()\n  message(sprintf(\"Total elapsed time: %.2f mins\", as.numeric(difftime(end_time, start_time, units = \"mins\"))))\n\n  list(power_summary = power_df, sim_object = sim)\n}\n\n# --------------------------------------------------------------------------------\n# Example call -------------------------------------------------------------------\n# --------------------------------------------------------------------------------\nresult &lt;- est_power_simengine(\n  n_pg               = 50,  # Multiple sample sizes\n  effect_min_values =  c(30, 60, 90, 120),          \n  s_between_values = seq(0.1, 0.3, by = 0.05),\n  s_within_values = seq(0.15, 0.35, by = 0.05),\n  baseline_days      = 7,\n  intervention_days  = 14,\n  sims               = sims_param, \n  cores              = cores_param     \n)\n\n# result &lt;- est_power_simengine(\n#   n_pg               = c(50),  # Multiple sample sizes\n#   effect_min_values =  c(30, 60, 90, 120),          \n#   s_between_values = seq(0.1, 0.3, by = 0.05),\n#   s_within_values = seq(0.15, 0.35, by = 0.05),\n#   baseline_days      = 7,\n#   intervention_days  = 14,\n#   sims               = sims_param, \n#   cores              = cores_param     \n# )\n# print(result$power_summary)\n\n# Save results with descriptive name and timestamp\ntimestamp &lt;- format(Sys.time(), \"%Y%m%d_%H%M%S\")\nfilename &lt;- paste0(\"scripts/sim_comp_debug/power_sim_results_\", timestamp, \".RData\")\nsave(result, file = filename)\n\n# Print power summary\n# print(result$power_summary)\n\n# Print save location\nmessage(\"Results saved to: \", filename)\n\n# POWER SUMMARY ANALYSIS\nmessage(\"\\n\" , paste(rep(\"=\", 60), collapse=\"\"))\nmessage(\"POWER SUMMARY - TOP PERFORMING SETTINGS\")\nmessage(paste(rep(\"=\", 60), collapse=\"\"))\n\npower_data &lt;- result$power_summary\n\n# Summary for power_interaction\nmessage(\"\\n🎯 INTERACTION EFFECT POWER SUMMARY:\")\nmessage(\"-----------------------------------\")\n\n# Find maximum power for interaction\nmax_interaction_power &lt;- max(power_data$power_interaction, na.rm = TRUE)\nbest_interaction &lt;- power_data[which.max(power_data$power_interaction), ]\n\nmessage(sprintf(\"Maximum Interaction Power: %.3f\", max_interaction_power))\nmessage(\"Best settings:\")\nmessage(sprintf(\"  • Sample size per group (n_pg): %d\", best_interaction$n_pg))\nmessage(sprintf(\"  • Effect size (effect_min): %d minutes\", best_interaction$effect_min))\nmessage(sprintf(\"  • Between-subject SD (s_between): %.3f\", best_interaction$s_between))\nmessage(sprintf(\"  • Within-subject SD (s_within): %.3f\", best_interaction$s_within))\n\n# Show top 3 settings for interaction\nmessage(\"\\nTop 3 settings for interaction power:\")\ntop_interaction &lt;- power_data[order(power_data$power_interaction, decreasing = TRUE)[1:min(3, nrow(power_data))], ]\nfor(i in 1:nrow(top_interaction)) {\n  row &lt;- top_interaction[i, ]\n  message(sprintf(\"%d. Power=%.3f | n_pg=%d | effect=%d | s_between=%.3f | s_within=%.3f\", \n                  i, row$power_interaction, row$n_pg, row$effect_min, row$s_between, row$s_within))\n}\n\n# Summary for power_protocol  \nmessage(\"\\n🎯 PROTOCOL EFFECT POWER SUMMARY:\")\nmessage(\"--------------------------------\")\n\n# Find maximum power for protocol\nmax_protocol_power &lt;- max(power_data$power_protocol, na.rm = TRUE)\nbest_protocol &lt;- power_data[which.max(power_data$power_protocol), ]\n\nmessage(sprintf(\"Maximum Protocol Power: %.3f\", max_protocol_power))\nmessage(\"Best settings:\")\nmessage(sprintf(\"  • Sample size per group (n_pg): %d\", best_protocol$n_pg))\nmessage(sprintf(\"  • Effect size (effect_min): %d minutes\", best_protocol$effect_min))\nmessage(sprintf(\"  • Between-subject SD (s_between): %.3f\", best_protocol$s_between))\nmessage(sprintf(\"  • Within-subject SD (s_within): %.3f\", best_protocol$s_within))\n\n# Show top 3 settings for protocol\nmessage(\"\\nTop 3 settings for protocol power:\")\ntop_protocol &lt;- power_data[order(power_data$power_protocol, decreasing = TRUE)[1:min(3, nrow(power_data))], ]\nfor(i in 1:nrow(top_protocol)) {\n  row &lt;- top_protocol[i, ]\n  message(sprintf(\"%d. Power=%.3f | n_pg=%d | effect=%d | s_between=%.3f | s_within=%.3f\", \n                  i, row$power_protocol, row$n_pg, row$effect_min, row$s_between, row$s_within))\n}\n\n# Overall summary statistics\nmessage(\"\\n📊 OVERALL POWER STATISTICS:\")\nmessage(\"---------------------------\")\nmessage(sprintf(\"Interaction Power - Mean: %.3f, Range: %.3f - %.3f\", \n                mean(power_data$power_interaction, na.rm = TRUE),\n                min(power_data$power_interaction, na.rm = TRUE),\n                max(power_data$power_interaction, na.rm = TRUE)))\n                \nmessage(sprintf(\"Protocol Power - Mean: %.3f, Range: %.3f - %.3f\", \n                mean(power_data$power_protocol, na.rm = TRUE),\n                min(power_data$power_protocol, na.rm = TRUE),\n                max(power_data$power_protocol, na.rm = TRUE)))\n\n# DATA QUALITY ANALYSIS\nmessage(\"\\n\" , paste(rep(\"=\", 60), collapse=\"\"))\nmessage(\"DATA QUALITY ANALYSIS - VALIDITY RATES\")\nmessage(paste(rep(\"=\", 60), collapse=\"\"))\n\n# Check validity rates for each contrast\nvalidity_threshold &lt;- 0.95\ntotal_rows &lt;- nrow(power_data)\n\n# Function to analyze validity for each contrast\nanalyze_validity &lt;- function(valid_col, contrast_name) {\n  high_validity_count &lt;- sum(power_data[[valid_col]] &gt; validity_threshold, na.rm = TRUE)\n  perfect_validity_count &lt;- sum(power_data[[valid_col]] == 1.0, na.rm = TRUE)\n  mean_validity &lt;- mean(power_data[[valid_col]], na.rm = TRUE)\n  min_validity &lt;- min(power_data[[valid_col]], na.rm = TRUE)\n  \n  message(sprintf(\"\\n🔍 %s VALIDITY:\", toupper(contrast_name)))\n  message(sprintf(\"  • Rows with validity &gt; %.2f: %d/%d (%.1f%%)\", \n                  validity_threshold, high_validity_count, total_rows, \n                  100 * high_validity_count / total_rows))\n  message(sprintf(\"  • Rows with perfect validity (1.0): %d/%d (%.1f%%)\", \n                  perfect_validity_count, total_rows, \n                  100 * perfect_validity_count / total_rows))\n  message(sprintf(\"  • Mean validity: %.3f\", mean_validity))\n  message(sprintf(\"  • Minimum validity: %.3f\", min_validity))\n  \n  # Identify problematic parameter combinations if any\n  if (high_validity_count &lt; total_rows) {\n    low_validity_rows &lt;- power_data[power_data[[valid_col]] &lt;= validity_threshold, ]\n    message(sprintf(\"  ⚠️  %d rows with validity ≤ %.2f:\", \n                    nrow(low_validity_rows), validity_threshold))\n    for(i in 1:min(3, nrow(low_validity_rows))) {  # Show up to 3 examples\n      row &lt;- low_validity_rows[i, ]\n      message(sprintf(\"     Example %d: validity=%.3f | n_pg=%d | effect=%d | s_between=%.3f | s_within=%.3f\", \n                      i, row[[valid_col]], row$n_pg, row$effect_min, row$s_between, row$s_within))\n    }\n    if (nrow(low_validity_rows) &gt; 3) {\n      message(sprintf(\"     ... and %d more problematic combinations\", nrow(low_validity_rows) - 3))\n    }\n  } else {\n    message(\"  ✅ All parameter combinations produced high-quality results!\")\n  }\n  \n  return(list(\n    high_validity_count = high_validity_count,\n    perfect_validity_count = perfect_validity_count,\n    mean_validity = mean_validity,\n    min_validity = min_validity\n  ))\n}\n\n# Analyze each contrast type\ncontrasts &lt;- list(\n  \"valid_between\" = \"Between-Group\",\n  \"valid_control\" = \"Control Within-Group\", \n  \"valid_intervention\" = \"Intervention Within-Group\",\n  \"valid_interaction\" = \"Group × Period Interaction\",\n  \"valid_protocol\" = \"Per-Protocol\"\n)\n\nvalidity_summary &lt;- list()\nfor(col in names(contrasts)) {\n  validity_summary[[col]] &lt;- analyze_validity(col, contrasts[[col]])\n}\n\n# Overall validity summary\nmessage(\"\\n📋 OVERALL VALIDITY SUMMARY:\")\nmessage(\"---------------------------\")\nall_high_validity &lt;- sapply(validity_summary, function(x) x$high_validity_count)\nall_perfect_validity &lt;- sapply(validity_summary, function(x) x$perfect_validity_count)\nall_mean_validity &lt;- sapply(validity_summary, function(x) x$mean_validity)\n\nmessage(sprintf(\"Contrast with highest reliability: %s (%d/%d rows &gt; %.2f)\", \n                contrasts[[which.max(all_high_validity)]], \n                max(all_high_validity), total_rows, validity_threshold))\nmessage(sprintf(\"Contrast with lowest reliability: %s (%d/%d rows &gt; %.2f)\", \n                contrasts[[which.min(all_high_validity)]], \n                min(all_high_validity), total_rows, validity_threshold))\n\n# Check if all contrasts are highly reliable\nif(all(all_high_validity == total_rows)) {\n  message(\"✅ EXCELLENT: All contrasts have high validity (&gt;95%) across all parameter combinations!\")\n} else {\n  problematic_contrasts &lt;- names(contrasts)[all_high_validity &lt; total_rows]\n  message(sprintf(\"⚠️  WARNING: %d contrast(s) have some parameter combinations with low validity:\", \n                  length(problematic_contrasts)))\n  for(contrast in problematic_contrasts) {\n    message(sprintf(\"   • %s: %d/%d rows with validity ≤ %.2f\", \n                    contrasts[[contrast]], \n                    total_rows - all_high_validity[[contrast]], \n                    total_rows, validity_threshold))\n  }\n}\n\nmessage(\"\\n\" , paste(rep(\"=\", 60), collapse=\"\"))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Simulation-based Power Analysis for Two-arm RCT with Compositional Outcomes</span>"
    ]
  },
  {
    "objectID": "scripts/sim_comp_report.html#simulate-study",
    "href": "scripts/sim_comp_report.html#simulate-study",
    "title": "3  Simulation-based Power Analysis for Two-arm RCT with Compositional Outcomes",
    "section": "3.5 Simulate study",
    "text": "3.5 Simulate study\n\n\nCode\n# Source the generate_data function (assuming it's in the sim_engine_demo.R file)\ngenerate_data &lt;- function(n_pg, effect_min, baseline_days, intervention_days,\n                          s_between, s_within, seed = NULL) {\n\n  if (!is.null(seed)) set.seed(seed)\n\n  N   &lt;- n_pg * 2\n  grp &lt;- rep(0:1, each = n_pg)              # 0 = Control, 1 = Intervention\n\n  # Mean daily compositions: (sedentary, sleep, physical)\n  base_comp   &lt;- c(600, 480, 360)\n  active_comp &lt;- c(600 - effect_min, 480, 360 + effect_min)\n\n  # Person‑level random effects in ILR space\n  b_ilr &lt;- MASS::mvrnorm(N, mu = c(0, 0), Sigma = diag(s_between^2, 2))\n\n  # Person-specific playtime proportion of sedentary time (10-40%)\n  personal_play_prop &lt;- sapply(1:N, function(i) {\n    p &lt;- rbeta(1, 2, 5) * 0.3 + 0.1  # right-skew between 0.1-0.4\n    return(p)\n  })\n\n  # Containers\n  all_ids &lt;- all_periods &lt;- all_days &lt;- NULL\n  all_ilr &lt;- matrix(, 0, 2)\n  all_sedentary &lt;- numeric()  # Store actual sedentary minutes\n\n  for (i in seq_len(N)) {\n    for (period in c(\"baseline\", \"intervention\")) {\n      ndays   &lt;- if (period == \"baseline\") baseline_days else intervention_days\n      comp_mu &lt;- if (period == \"baseline\" || grp[i] == 0) base_comp else active_comp\n\n      comp_ilr &lt;- comp_to_ilr(matrix(rep(comp_mu, ndays), ncol = 3, byrow = TRUE))\n      comp_ilr &lt;- sweep(comp_ilr, 2, b_ilr[i, ], \"+\")               # add person RE\n      day_ilr  &lt;- comp_ilr + MASS::mvrnorm(ndays, mu = c(0, 0),\n                                            Sigma = diag(s_within^2, 2))\n\n      # Index bookkeeping\n      all_ids     &lt;- c(all_ids, rep(i, ndays))\n      all_periods &lt;- c(all_periods, rep(period, ndays))\n      all_days    &lt;- c(all_days,\n                        if (period == \"baseline\") seq_len(baseline_days)\n                        else baseline_days + seq_len(intervention_days))\n      all_ilr     &lt;- rbind(all_ilr, day_ilr)\n      \n      # Store sedentary minutes for this person-period (will be calculated after ILR transformation)\n      # We'll calculate playtime after we have the actual sedentary minutes\n    }\n  }\n\n  # Back‑transform ILR → minutes and calculate playtime based on actual sedentary behavior\n  mins &lt;- ilr_to_minutes(all_ilr)\n  colnames(mins) &lt;- c(\"sedentary\", \"sleep\", \"physical\")\n  \n  # Now generate playtime based on actual sedentary minutes\n  playmin &lt;- numeric(length(all_ids))\n  \n  for (i in seq_along(all_ids)) {\n    person_id &lt;- all_ids[i]\n    period &lt;- all_periods[i]\n    actual_sedentary &lt;- mins[i, \"sedentary\"]\n    \n    # Base playtime as proportion of actual sedentary time\n    base_playtime &lt;- personal_play_prop[person_id] * actual_sedentary\n    \n    # Add small amount of day-to-day noise (2% of base playtime)\n    daily_sd &lt;- 0.02 * base_playtime\n    noisy_playtime &lt;- rnorm(1, base_playtime, daily_sd)\n    \n    # Apply intervention effect for intervention group during intervention period\n    if (period == \"intervention\" && grp[person_id] == 1) {\n      # Reduce playtime by effect_min, but ensure it doesn't go below 0\n      # The reduction is additive (in minutes) to maintain the intended effect size\n      intervention_playtime &lt;- pmax(0, noisy_playtime - effect_min)\n      playmin[i] &lt;- intervention_playtime\n    } else {\n      # Control group or baseline period: just use the playtime based on actual sedentary\n      playmin[i] &lt;- pmax(0, noisy_playtime)  # Ensure non-negative\n    }\n  }\n\n  # Assemble data frame\n  dat &lt;- data.frame(\n    id        = factor(all_ids),\n    group     = factor(grp[all_ids], labels = c(\"Control\", \"Abstinence\")),\n    period    = factor(all_periods, levels = c(\"baseline\", \"intervention\")),\n    day       = all_days,\n    sedentary = mins[, 1],\n    sleep     = mins[, 2],\n    physical  = mins[, 3],\n    playtime  = playmin\n  )\n\n  dat &lt;- dat %&gt;%\n    group_by(id) %&gt;%\n    mutate(\n      base_play_mean      = mean(playtime[period == \"baseline\"]),\n      playtime_reduction  = base_play_mean - playtime,\n      intervention_active = as.integer(group == \"Abstinence\" & period == \"intervention\")\n    ) %&gt;%\n    ungroup()\n\n  return(dat)\n}\n# Generate sample data with moderate effect size\nset.seed(123)\nsample_data &lt;- generate_data(\n  n_pg = 50,              # 50 participants per group\n  effect_min = 60,         \n  baseline_days = 7,      # 7 days baseline\n  intervention_days = 14, # 14 days intervention\n  s_between = 0.3,        # moderate between-subject variability\n  s_within = 0.2,         # moderate within-subject variability\n  seed = 123\n)\n\n# Check the structure of the generated data\nglimpse(sample_data)\n\n\nRows: 2,100\nColumns: 11\n$ id                  &lt;fct&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ group               &lt;fct&gt; Control, Control, Control, Control, Control, Contr…\n$ period              &lt;fct&gt; baseline, baseline, baseline, baseline, baseline, …\n$ day                 &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,…\n$ sedentary           &lt;dbl&gt; 424.2, 599.8, 532.8, 539.3, 511.4, 586.7, 606.4, 5…\n$ sleep               &lt;dbl&gt; 670.0, 538.0, 668.0, 480.7, 562.6, 530.5, 449.5, 5…\n$ physical            &lt;dbl&gt; 345.8, 302.2, 239.3, 420.0, 366.1, 322.8, 384.1, 3…\n$ playtime            &lt;dbl&gt; 120.73684, 173.81501, 151.84373, 156.04261, 142.45…\n$ base_play_mean      &lt;dbl&gt; 155.1893, 155.1893, 155.1893, 155.1893, 155.1893, …\n$ playtime_reduction  &lt;dbl&gt; 34.4524824, -18.6256825, 3.3455976, -0.8532876, 12…\n$ intervention_active &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n\n\n\n\nCode\n# Calculate daily means for compositions across all participants by group and period\ndaily_composition_means &lt;- sample_data %&gt;%\n  group_by(group, period, day) %&gt;%\n  summarise(\n    sedentary_mean = mean(sedentary),\n    sleep_mean = mean(sleep),\n    physical_mean = mean(physical),\n    .groups = \"drop\"\n  ) %&gt;%\n  pivot_longer(\n    cols = c(sedentary_mean, sleep_mean, physical_mean),\n    names_to = \"component\",\n    values_to = \"minutes\"\n  ) %&gt;%\n  mutate(\n    component = factor(\n      gsub(\"_mean\", \"\", component),\n      levels = c(\"sedentary\", \"sleep\", \"physical\"),\n      labels = c(\"Sedentary\", \"Sleep\", \"Physical Activity\")\n    )\n  )\n\n# Longitudinal compositional barplot\ncomposition_longitudinal &lt;- ggplot(daily_composition_means, \n                                  aes(x = day, y = minutes, fill = component)) +\n  geom_col(position = \"stack\", alpha = 0.8) +\n  geom_vline(xintercept = 7.5, linetype = \"dashed\", color = \"black\", size = 1) +\n  annotate(\"text\", x = 4, y = 1300, label = \"Baseline\", hjust = 0.5, size = 4, fontface = \"bold\") +\n  annotate(\"text\", x = 14, y = 1300, label = \"Intervention\", hjust = 0.5, size = 4, fontface = \"bold\") +\n  facet_wrap(~ group, \n             labeller = labeller(\n               group = c(\"Control\" = \"Control Group\", \"Abstinence\" = \"Abstinence Group\")\n             )) +\n  labs(\n    title = \"Daily Mean Compositions Over Time\",\n    subtitle = \"24-hour time use patterns by study day (stacked bars)\",\n    x = \"Study Day\",\n    y = \"Minutes per Day\",\n    fill = \"Component\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"bottom\",\n    strip.text = element_text(size = 12, face = \"bold\"),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.x = element_blank()\n  ) +\n  scale_fill_viridis_d(option = \"plasma\", begin = 0.2, end = 0.8) +\n  scale_y_continuous(breaks = seq(0, 1400, 200)) +\n  scale_x_continuous(breaks = seq(0, 25, 5))\n\nprint(composition_longitudinal)\n\n\n\n\n\n\n\n\n\nCode\n# Calculate daily means for playtime by group and period\ndaily_playtime_means &lt;- sample_data %&gt;%\n  group_by(group, period, day) %&gt;%\n  summarise(\n    playtime_mean = mean(playtime),\n    playtime_se = sd(playtime) / sqrt(n()),\n    .groups = \"drop\"\n  )\n\n# Longitudinal plot for daily mean playtime - now faceted by group like the composition plot\nplaytime_longitudinal &lt;- ggplot(daily_playtime_means, \n                               aes(x = day, y = playtime_mean, color = group)) +\n  geom_line(size = 1.2, alpha = 0.8) +\n  geom_point(size = 2, alpha = 0.7) +\n  geom_ribbon(aes(ymin = playtime_mean - playtime_se, \n                  ymax = playtime_mean + playtime_se, \n                  fill = group), \n              alpha = 0.2, color = NA) +\n  geom_vline(xintercept = 7.5, linetype = \"dashed\", color = \"black\", size = 1) +\n  annotate(\"text\", x = 4, y = 175, label = \"Baseline\", hjust = 0.5, size = 4, fontface = \"bold\") +\n  annotate(\"text\", x = 14, y = 175, label = \"Intervention\", hjust = 0.5, size = 4, fontface = \"bold\") +\n  facet_wrap(~ group, \n             labeller = labeller(\n               group = c(\"Control\" = \"Control Group\", \"Abstinence\" = \"Abstinence Group\")\n             )) +\n  labs(\n    title = \"Daily Mean Playtime Over Time\",\n    subtitle = \"Gaming/screen time trends by study day with standard error bands\",\n    x = \"Study Day\",\n    y = \"Mean Playtime (minutes per day)\",\n    color = \"Group\",\n    fill = \"Group\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"bottom\",\n    strip.text = element_text(size = 12, face = \"bold\"),\n    panel.grid.minor.x = element_blank()\n  ) +\n  scale_color_manual(values = c(\"Control\" = \"#2E8B57\", \"Abstinence\" = \"#FF6347\")) +\n  scale_fill_manual(values = c(\"Control\" = \"#2E8B57\", \"Abstinence\" = \"#FF6347\")) +\n  scale_y_continuous(breaks = seq(0, 200, 25)) +\n  scale_x_continuous(breaks = seq(0, 25, 5))\n\nprint(playtime_longitudinal)\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Calculate daily averages for compositions by group and period\ncomposition_summary &lt;- sample_data %&gt;%\n  group_by(group, period, id) %&gt;%\n  summarise(\n    sedentary = mean(sedentary),\n    sleep = mean(sleep), \n    physical = mean(physical),\n    .groups = \"drop\"\n  ) %&gt;%\n  pivot_longer(\n    cols = c(sedentary, sleep, physical),\n    names_to = \"component\",\n    values_to = \"minutes\"\n  ) %&gt;%\n  mutate(\n    component = factor(component, \n                      levels = c(\"sedentary\", \"sleep\", \"physical\"),\n                      labels = c(\"Sedentary\", \"Sleep\", \"Physical Activity\"))\n  )\n\n# Create 2x2 faceted plot for compositions\ncomposition_plot &lt;- ggplot(composition_summary, \n                          aes(x = component, y = minutes, fill = component)) +\n  geom_boxplot(alpha = 0.7) +\n  geom_point(position = position_jitter(width = 0.2), alpha = 0.3, size = 0.8) +\n  facet_grid(period ~ group, \n             labeller = labeller(\n               period = c(\"baseline\" = \"Baseline\", \"intervention\" = \"Intervention\"),\n               group = c(\"Control\" = \"Control Group\", \"Abstinence\" = \"Abstinence Group\")\n             )) +\n  labs(\n    title = \"Daily Average Compositions by Group and Period\",\n    subtitle = \"24-hour time use patterns (minutes per day)\",\n    x = \"Activity Component\",\n    y = \"Minutes per Day\",\n    fill = \"Component\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"bottom\",\n    strip.text = element_text(size = 12, face = \"bold\"),\n    axis.text.x = element_text(angle = 45, hjust = 1)\n  ) +\n  scale_fill_viridis_d(option = \"plasma\", begin = 0.2, end = 0.8) +\n  scale_y_continuous(breaks = seq(0, 800, 100))\n\nprint(composition_plot)\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Calculate playtime averages by group and period  \nplaytime_summary &lt;- sample_data %&gt;%\n  group_by(group, period, id) %&gt;%\n  summarise(\n    avg_playtime = mean(playtime),\n    .groups = \"drop\"\n  )\n\n# Create 2x2 faceted plot for playtime\nplaytime_plot &lt;- ggplot(playtime_summary, \n                       aes(x = group, y = avg_playtime, fill = group)) +\n  geom_boxplot(alpha = 0.7, width = 0.6) +\n  geom_point(position = position_jitter(width = 0.2), alpha = 0.5, size = 1.2) +\n  stat_summary(fun = mean, geom = \"point\", shape = 23, size = 3, \n               fill = \"white\", color = \"black\") +\n  facet_wrap(~ period, \n             labeller = labeller(\n               period = c(\"baseline\" = \"Baseline Period\", \n                         \"intervention\" = \"Intervention Period\")\n             )) +\n  labs(\n    title = \"Average Daily Playtime by Group and Period\",\n    subtitle = \"Gaming/screen time reduction intervention effect\",\n    x = \"Study Group\",\n    y = \"Average Playtime (minutes per day)\",\n    fill = \"Group\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"bottom\",\n    strip.text = element_text(size = 12, face = \"bold\"),\n    panel.grid.minor = element_blank()\n  ) +\n  scale_fill_manual(values = c(\"Control\" = \"#2E8B57\", \"Intervention\" = \"#FF6347\")) +\n  scale_y_continuous(breaks = seq(0, 200, 25))\n\nprint(playtime_plot)\n\n\n\n\n\n\n\n\n\nCode\n# Summary statistics table\nplaytime_stats &lt;- playtime_summary %&gt;%\n  group_by(group, period) %&gt;%\n  summarise(\n    n = n(),\n    mean_playtime = round(mean(avg_playtime), 1),\n    sd_playtime = round(sd(avg_playtime), 1),\n    median_playtime = round(median(avg_playtime), 1),\n    q25 = round(quantile(avg_playtime, 0.25), 1),\n    q75 = round(quantile(avg_playtime, 0.75), 1),\n    .groups = \"drop\"\n  )\n\n# Display summary table\nknitr::kable(\n  playtime_stats,\n  caption = \"Summary Statistics for Daily Playtime by Group and Period\",\n  col.names = c(\"Group\", \"Period\", \"N\", \"Mean\", \"SD\", \"Median\", \"Q25\", \"Q75\")\n)\n\n\n\nSummary Statistics for Daily Playtime by Group and Period\n\n\nGroup\nPeriod\nN\nMean\nSD\nMedian\nQ25\nQ75\n\n\n\n\nControl\nbaseline\n50\n106.1\n36.0\n104.4\n80.4\n120.8\n\n\nControl\nintervention\n50\n106.3\n37.5\n99.0\n78.0\n121.4\n\n\nAbstinence\nbaseline\n50\n118.0\n48.9\n107.7\n80.1\n134.1\n\n\nAbstinence\nintervention\n50\n10.2\n25.1\n0.0\n0.0\n5.1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Simulation-based Power Analysis for Two-arm RCT with Compositional Outcomes</span>"
    ]
  }
]